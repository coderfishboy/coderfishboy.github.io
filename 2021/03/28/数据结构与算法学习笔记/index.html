<!DOCTYPE html>
<html lang="zh-CN">


<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"coderfishboy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="@TOC 1.线性表（说白点就是C语言讲的数组和链表）线性表的概念：线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线串起来，再存储到物理空间中”。线性表存储结构可细分为顺序存储结构和链式存储结构。线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记">
<meta property="og:url" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="迹忆拾光">
<meta property="og:description" content="@TOC 1.线性表（说白点就是C语言讲的数组和链表）线性表的概念：线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线串起来，再存储到物理空间中”。线性表存储结构可细分为顺序存储结构和链式存储结构。线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021031417552791.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314175805162.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314175850776.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180154658.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180207456.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314180314177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314180618773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314180625213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031418064189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314180659527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314180707763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021031418081272.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180820554.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180839529.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180908886.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181022479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181214653.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181342435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181405768.png">
<meta property="og:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181412222.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181550983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181603552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031418161257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181717477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031418175728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314181816810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314182007330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031418203791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314182129124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021031219171071.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210312191721220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210312191741361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314215626489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210314215847316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-03-28T07:51:17.000Z">
<meta property="article:modified_time" content="2021-05-07T07:34:13.989Z">
<meta property="article:author" content="Shi Defa">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021031417552791.png">

<link rel="canonical" href="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法学习笔记 | 迹忆拾光</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="迹忆拾光" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">迹忆拾光</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醒醒该吃饭啦</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Shi Defa">
      <meta itemprop="description" content="来点小烧烤吗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迹忆拾光">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-28 15:51:17" itemprop="dateCreated datePublished" datetime="2021-03-28T15:51:17+08:00">2021-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 15:34:13" itemprop="dateModified" datetime="2021-05-07T15:34:13+08:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>63k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> @<a href="%E7%9B%AE%E5%BD%95">TOC</a></p>
<h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><p>（说白点就是C语言讲的<strong>数组</strong>和<strong>链表</strong>）<br><strong>线性表的概念：</strong><br>线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线串起来，再存储到物理空间中”。线性表存储结构可细分为<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。<br>线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。<br>不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。<br>顺序表常见代码：<strong>插入、删除、查找、更改</strong>（其实就是数组的一系列操作）</p>
<h3 id="（1）数组"><a href="#（1）数组" class="headerlink" title="（1）数组"></a>（1）数组</h3><p>掌握C语言课本上及《新编C语言习题与解析》上面的练习题例题就可以</p>
<h3 id="（2）栈"><a href="#（2）栈" class="headerlink" title="（2）栈"></a>（2）栈</h3><p><strong>1.栈的概念：</strong><br>同顺序表和链表一样，栈也是用来存储逻辑关系为“一对一”数据的线性存储结构<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021031417552791.png" alt="在这里插入图片描述"></p>
<p>从图我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：<br>1.栈只能从表的一端存取数据，另一端是封闭的，如图所示；<br>2.在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。<br>因此，我们可以给栈下一个定义，即<strong>栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构</strong>。<br><strong>2.栈的应用：</strong><br>基于栈结构对数据存取采用 “先进后出” 原则的特点， 它可以用于实现很多功能。<br>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：<br>重新搜索找到页面 A；<br>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。<br>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。<br>不仅如此，栈存储结构还可以帮我们<strong>检测代码中的括号匹配问题</strong>。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。<br>同时，栈结构还可以实现数值的进制转换功能。例如，编写程序实现从<strong>十进制数自动转换成二进制数</strong>，就可以使用栈存储结构来实现。<br>还有类似的在递归调用问题中（汉诺塔等）也可以使用栈。<br><strong>3.栈的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//元素elem进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> top,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>,a[top]);</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    top=push(a, top, <span class="number">1</span>);</span><br><span class="line">    top=push(a, top, <span class="number">2</span>);</span><br><span class="line">    top=push(a, top, <span class="number">3</span>);</span><br><span class="line">    top=push(a, top, <span class="number">4</span>);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    top=pop(a, top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果为：</p>
<blockquote>
<p>弹栈元素：4<br>弹栈元素：3<br>弹栈元素：2<br>弹栈元素：1<br>空栈</p>
</blockquote>
<p><strong>4.链栈的概念：</strong><br>即用链表实现栈存储结构。<br>链栈的实现思路同顺序栈类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图所示：</p>
<p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。<br>链表的头部作为栈顶，意味着：<br>在实现数据”入栈”操作时，需要将数据从链表的头部插入；<br>在实现数据”出栈”操作时，需要删除链表头部的首元节点；<br>因此，链栈实际上就是一个<strong>只能采用头插法插入或删除数据的链表</strong>。<br><strong>5.链栈的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="comment">//stack为当前的链栈，a表示入栈元素</span></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储新元素的节点</span></span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    <span class="comment">//新节点与头节点建立逻辑关系</span></span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//更新头指针的指向</span></span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈顶元素出链栈的实现函数</span></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="comment">//声明一个新指针指向栈顶节点</span></span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">//更新头指针</span></span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈元素：%d &quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新栈顶元素：%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈已空\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈内没有元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果为：</p>
<blockquote>
<p>弹栈元素：4 栈顶元素：3<br>弹栈元素：3 栈顶元素：2<br>弹栈元素：2 栈顶元素：1<br>弹栈元素：1 栈已空<br>栈内没有元素</p>
</blockquote>
<h3 id="（3）队列"><a href="#（3）队列" class="headerlink" title="（3）队列"></a>（3）队列</h3><p><strong>队列的概念：</strong><br>队列，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。<br>与栈结构不同的是，队列的两端都”开口”，要求数据只能从一端进，从另一端出，如图所示：<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314175805162.png" alt="在这里插入图片描述"></p>
<p>队列中数据的进出要遵循 “先进先出” 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。<br><strong>队列的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    a[rear]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (front!=rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d\n&quot;</span>,a[front]);</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a, rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<blockquote>
<p>出队元素：1<br>出队元素：2<br>出队元素：3<br>出队元素：4</p>
</blockquote>
<p><strong>链式队列</strong>：实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如图所示:<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314175850776.png" alt="在这里插入图片描述"></p>
<p><strong>链队的实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    enElem-&gt;data=data;</span><br><span class="line">    enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//使用尾插法向链队列中添加数据元素</span></span><br><span class="line">    rear-&gt;next=enElem;</span><br><span class="line">    rear=enElem;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line">    QNode * p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line">    p=top-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">    top-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">        rear=top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QNode * <span class="built_in">queue</span>,*top,*rear;</span><br><span class="line">    <span class="built_in">queue</span>=top=rear=initQueue();<span class="comment">//创建头结点</span></span><br><span class="line">    <span class="comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span></span><br><span class="line">    rear=enQueue(rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//入队完成，所有数据元素开始出队列</span></span><br><span class="line">    rear=DeQueue(top, rear);</span><br><span class="line">    rear=DeQueue(top, rear);</span><br><span class="line">    rear=DeQueue(top, rear);</span><br><span class="line">    rear=DeQueue(top, rear);</span><br><span class="line">    rear=DeQueue(top, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果为：</p>
<blockquote>
<p>1 2 3 4<br>队列为空</p>
</blockquote>
<h3 id="（4）链表"><a href="#（4）链表" class="headerlink" title="（4）链表"></a>（4）链表</h3><p>（掌握c语言结构体章课后习题：<strong>插入、转置、删除、合并等课后习题及例题就可以</strong>）<br>链表，别名链式存储结构或单链表，用于存储逻辑关系为 “一对一” 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是<strong>随机的</strong>。</p>
<blockquote>
<p><strong>问题1（2015-6-1）</strong><br>编写一个程序，从键盘任意输入10个整数建立一个单向链表；再设计一个函数，完成对该单向链表的就地逆置（即利用原有的节点将链表反向链接）；在主函数中打印输出逆置后的链表。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(struct number)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">number</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建链表函数（背过！），返回值为首地址</span></span><br><span class="line"><span class="function">struct number *<span class="title">creat</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">number</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">number</span> *<span class="title">p1</span> =</span> <span class="literal">NULL</span>, *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    p2 = p1 = (struct number *)<span class="built_in">malloc</span>(LEN);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num); <span class="comment">//给第一个结点赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">//若是第一个结点则head 指向</span></span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2-&gt;next = p1; <span class="comment">//否则形成链表</span></span><br><span class="line">        p2 = p1;</span><br><span class="line">        p1 = (struct number *)<span class="built_in">malloc</span>(LEN); <span class="comment">//再次申请</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>; <span class="comment">//最后一个结点指向空</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct number *<span class="title">reverse_list</span><span class="params">(struct number *head)</span> <span class="comment">//逆置，返回head</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">number</span> *<span class="title">temp</span> =</span> <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        head = p; <span class="comment">// 形成环路</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">number</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>, *pt = <span class="literal">NULL</span>;</span><br><span class="line">    pt = head = creat();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原链表:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (pt = <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, pt-&gt;num);</span><br><span class="line">        pt = pt-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆置：\n&quot;</span>);</span><br><span class="line">    pt = reverse_list(head);</span><br><span class="line">    <span class="keyword">while</span> (pt != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        输出;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题2（2014-5-3）</strong><br>已有a，b两个链表，每个链表中的结点包括学号、成绩，并且按照学号由小到大排列。要求把两个链表合并，仍然按学号升序排列。<br>已有说明如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(struct student)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> num;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">lista</span>, <span class="title">listb</span>;</span></span><br><span class="line"><span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已有函数建立好lista 和listb，合并链表的函数如下，调用时lista、listb 分别与参数ah 和bh 对应。请将程序补充完整。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct student *<span class="title">mul</span><span class="params">(struct student *ah, struct student *bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">pa1</span>, *<span class="title">pa2</span>, *<span class="title">pb1</span>, *<span class="title">pb2</span>;</span></span><br><span class="line">    pa2 = pa1 = ah;</span><br><span class="line">    pb2 = pb1 = bh;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((pb1-&gt;num &gt; pa1-&gt;num) &amp;&amp; (pa1-&gt;next != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            pa2 = pa1;</span><br><span class="line">            pa1 = pa1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pb1-&gt;num &lt;= pa1-&gt;num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ah == pa1)</span><br><span class="line">                ah = pb1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pa2-&gt;next = pb1;</span><br><span class="line">            pb1 = pb1-&gt;next;</span><br><span class="line">            pb2-&gt;next = pa1;</span><br><span class="line">            pa2 = pb2;</span><br><span class="line">            pb2 = pb1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pa1-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (pa1 == <span class="literal">NULL</span> &amp;&amp; pb1 != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span> ((pb1 != <span class="literal">NULL</span>) &amp;&amp; (pb1-&gt;num &gt; pa1-&gt;num) &amp;&amp; (pa1-&gt;next == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        pa1-&gt;next = pb1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ah;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-树"><a href="#2-树" class="headerlink" title="2.树"></a>2.树</h2><p>之前介绍的所有的数据结构都是线性存储结构。本章所介绍的树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180154658.png" alt="在这里插入图片描述"></p>
<p>图 1 是使用树结构存储的集合 {A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图。对于数据 A 来说，和数据 B、C、D 有关系；对于数据 B 来说，和 E、F 有关系。这就是“一对多”的关系。将具有“一对多”关系的集合中的数据元素按照图 1 的形式进行存储，整个存储形状在逻辑结构上看，类似于实际生活中倒着的树（图 2 倒过来），所以称这种存储结构为“树型”存储结构。<br>简单地理解，满足以下两个条件的树就是<strong>二叉树</strong>：<br>    本身是有序树；<br>    树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180207456.png" alt="在这里插入图片描述"></p>
<p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。<br><strong>满二叉树</strong>：如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。<br><strong>完全二叉树</strong>：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。<br><strong>堆不一定是完全二叉树</strong>，但是一般采用完全二叉树，主要是利于存储和运算</p>
<h3 id="（1）堆"><a href="#（1）堆" class="headerlink" title="（1）堆"></a>（1）堆</h3><p>（应该考不到这么难，涉及堆的创建代码量太大，基本掌握<strong>堆排序</strong>就可以）<br>堆的创建、删除、插入：<br><strong>堆的概念：</strong><br>如果有一个关键码集合K={K0,K1,…,Kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储在一个数组中，并满足：<br>Ki &lt;= K2<em>i + 1且Ki &lt;= K2*i + 2(Ki &lt; K2*i + 1且Ki &gt;= K2</em>i + 2)i = 0,1,2,…,则称为大堆（或小堆）。<br>通俗点说，堆就是一个任意节点都小于（或大于）其左右孩子节点的一个二叉树。<br><strong>堆的性质：</strong><br>堆存储在下标为0开始的数组中，因此它有以下特点：</p>
<ol>
<li>如果i = 0,节点i是根节点，没有双亲节点；否则节点i的双亲节点为节点（i - 1）/ 2。</li>
<li>如果2 * i + 1 &lt;= n - 1，则节点i的左孩子为节点2 * i + 1，否则节点i无左孩子。</li>
<li>如果2 * i + 2 &lt;= n - 1,则节点i的右孩子为节点 2 * i + 2，否则节点i无右孩子</li>
</ol>
<p> <img src="https://img-blog.csdnimg.cn/20210314180314177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>堆的创建</strong><br>创建堆就是将数组的数值一次让入到一个二叉树中，然后通过调整使其满足一个堆，其将二叉树调整为一个最小堆的原理就是从最后一个非叶子节点开始整理，一直到根节点为止，将每个节点及其子树调整到满足小堆的性质即可。<br>具体的调整方法：</p>
<ol>
<li>假设该节点下标为parent</li>
<li>找到该节点的左孩子left = parent * 2 + 1；</li>
<li>如果parent的右孩子节点存在，则取其左右孩子节点的最小值，和parent比较，若果比parnt小，则和parent值交换，然后就如上图一直调整，直到符合堆的性质为止。</li>
</ol>
<p><strong>堆的插入</strong><br>将新元素插入到最小堆的最后面，插入之后，对其进行上浮调整。<br>上浮思想：</p>
<ol>
<li>将要调整元素的下标定位child，首先需要找到child的父节点，parent = child - 1 / 2</li>
<li>比较child和parent的值，如果构建小堆，child的值小于parent的值，就进行交换。</li>
<li>然后让child = parent，parent = child - 1 / 2，以此循环</li>
</ol>
<p><strong>堆的删除</strong><br>每次删除堆顶元素的时候，先将堆顶的元素和堆的最后一个值进行交换，然后删除最后一个元素，再对第一个元素进行下沉处理。<br>下沉操作思想：</p>
<ol>
<li>先将下沉元素下标定位parent，找到其子节点child。</li>
<li>然后比较child，和child +<br>1的值，将较小的值和parent的值进行比较，如果建立的是小堆就，当child比parent小的时候就进行交换。</li>
<li>最后同上浮操作一样，以此循环。</li>
</ol>
<p><strong>堆的应用</strong><br>数组的排序：解决这个问题可以使用两种方法<br>方法一、创建一个堆，然后每次取堆顶元素，将其放入数组中，然后再删除堆顶元素，以此循环。但这个方法会开辟额外的空间。<br>方法二、这个方法主要是利用了堆的上浮和下沉操作，不需要创建额外的堆，并且所耗费的时间也相对较少。<br>实现代码如下:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/erwuhuoche/article/details/80368310">https://blog.csdn.net/erwuhuoche/article/details/80368310</a></p>
<p>堆排序代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> <span class="comment">//一次筛选的过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc, j;</span><br><span class="line">    rc = a[s];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m; j = j * <span class="number">2</span>) <span class="comment">//通过循环沿较大的孩子结点向下筛选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; a[j] &lt; a[j + <span class="number">1</span>])</span><br><span class="line">            j++; <span class="comment">//j为较大的记录的下标</span></span><br><span class="line">        <span class="keyword">if</span> (rc &gt; a[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a[s] = a[j];</span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    a[s] = rc; <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) <span class="comment">//通过循环初始化顶堆</span></span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[i];</span><br><span class="line">        a[i] = temp;             <span class="comment">//将堆顶记录与未排序的最后一个记录交换</span></span><br><span class="line">        HeapAdjust(a, <span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">//重新调整为顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    HeapSort(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）排序二叉树"><a href="#（2）排序二叉树" class="headerlink" title="（2）排序二叉树"></a>（2）排序二叉树</h3><p>二叉树排序的基本原理：先构建一颗空树，使用第一个元素作为根节点，如果之后的元素比第一个小，则放到左子树，否则放到右子树，之后按中序遍历。（注意：中序遍历和先序遍历及后序遍历的区别。中序遍历指输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间）。<br> <img src="https://img-blog.csdnimg.cn/20210314180618773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先序遍历结果：ABDHIEJCFKG<br> <img src="https://img-blog.csdnimg.cn/20210314180625213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>中序遍历可以想象成，<strong>按树画好的左右位置投影下来</strong>就可以了<br>中序遍历结果：HDIBEJAFKCG<br> <img src="https://img-blog.csdnimg.cn/2021031418064189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>后序遍历就像是剪葡萄，我们要把一串葡萄剪成一颗一颗的。<br>还记得我们先序遍历绕圈的路线么？<br>就是围着树的外围绕一圈，如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄），就把它剪下来，组成的就是后序遍历了。<br>后序遍历结果：HIDJEBKFGCA<br> <img src="https://img-blog.csdnimg.cn/20210314180659527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>层序遍历太简单了，就是按照一层一层的顺序，从左到右写下来就行了。<br>后序遍历结果：ABCDEFGHIJK<br> <img src="https://img-blog.csdnimg.cn/20210314180707763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>先序遍历</strong>顾名思义，就是在第一次经过这个结点的时候访问了它。就是从父节点来的这个箭头的时候，访问了它。<br><strong>中序遍历也</strong>和名字一样，就是在第二次经过这个结点的时候访问了它。就是从左孩子返回的这个箭头的时候，访问了它。<br><strong>后序遍历</strong>，就是在第三次经过这个结点的时候访问了它。就是从右孩子返回的这个箭头的时候，访问了它。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StdAfx.h&quot;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span>#<span class="meta-keyword">define</span> STACK_INCREMENT 10#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100#<span class="meta-keyword">define</span> MAXSIZE 50<span class="comment">//二叉排序树的链式存储结构typedef struct BiTNode&#123;    int data;    struct BiTNode *lchild, *rchild;&#125; BiTNode, *BiTree;//栈的顺序存储结构typedef struct&#123;    BiTree *base;    BiTree *top;    int stacksize;&#125; Sqstack;//初始化一个栈，用于二叉树的中序遍历void InitStack(Sqstack &amp;S)&#123;    S.base = (BiTree *)malloc(STACK_INIT_SIZE * sizeof(BiTNode));    if (!S.base)        exit(0);    S.top = S.base;    S.stacksize = STACK_INIT_SIZE;&#125;//二叉排序树查找void SearchBST(BiTree T, int key, BiTree f, BiTree &amp;p)&#123;    if (!T)        p = f;    else if (T-&gt;data == key)        p = T;    else if (T-&gt;data &lt; key)        SearchBST(T-&gt;rchild, key, T, p);    else        SearchBST(T-&gt;lchild, key, T, p);&#125;//创建一个二叉排序树void CreatBST(BiTree &amp;T, int e)&#123;    BiTree p, s, q;    SearchBST(T, e, NULL, p); //找到带插入的位置。    s = (BiTree)malloc(sizeof(BiTNode));    s-&gt;data = e;    s-&gt;lchild = NULL;    s-&gt;rchild = NULL;    if (!p)        T = s;    else if (e == p-&gt;data) //当待排序列中有相同的元素时，将其放在相同元素的右孩子位置。原来的右子树放在其右节点域。    &#123;        q = p-&gt;rchild;        p-&gt;rchild = s;        s-&gt;rchild = q;    &#125;    else if (e &lt; p-&gt;data)        p-&gt;lchild = s;    else        p-&gt;rchild = s;&#125;//中序遍历二叉排序树void InOrderTravese(BiTree T)&#123;    BiTree p;    Sqstack Sqt;    InitStack(Sqt);    p = T;    while (p || Sqt.base != Sqt.top)    &#123;        if (p)        &#123;            if (Sqt.top - Sqt.base &gt;= Sqt.stacksize)            &#123;                Sqt.base = (BiTree *)realloc(Sqt.base, (Sqt.stacksize + STACK_INCREMENT) * sizeof(BiTNode));                if (!Sqt.base)                    exit(OVERFLOW);                Sqt.top = Sqt.base + Sqt.stacksize;                Sqt.stacksize += STACK_INCREMENT;            &#125;            *Sqt.top++ = p;            p = p-&gt;lchild;        &#125;        else        &#123;            p = *--Sqt.top;            printf(&quot;%d &quot;, p-&gt;data);            p = p-&gt;rchild;        &#125;    &#125;    printf(&quot;\n&quot;);&#125;void main()&#123;    int length;    int bst[MAXSIZE];    BiTree BST;    BST = (BiTree)malloc(sizeof(BiTNode));    BST = NULL;    printf(&quot;***************************\n&quot;);    printf(&quot;      二叉树排序算法       \n&quot;);    printf(&quot;***************************\n&quot;);    printf(&quot;请输入待排序序列的个数N (N&lt;%d)：&quot;, MAXSIZE);    scanf(&quot;%d&quot;, &amp;length);    printf(&quot;\n&quot;);    printf(&quot;请输入待排序的关键字：\n&quot;);    for (int i = 0; i &lt; length; i++)        scanf(&quot;%d&quot;, &amp;bst[i]);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; length; i++)        CreatBST(BST, bst[i]);    printf(&quot;输出二叉树排序结果：\n&quot;);    InOrderTravese(BST);    printf(&quot;\n&quot;);    free(BST);&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h2><p>哈希表原理：如果说每一个数据它都对应着一个固定的位置，那我们查找特定一个数据时，就可以直接查看这个数据对应的位置是否存在数据。一个形象的例子就是学生在教室中的位置，开学的时候，老师会给学生每一个人分配一个位置，而且不允许学生随便乱坐位置，以后老师要查看今天李刚同学有没有上课，直接看李刚同学的位置是不是有人坐就可以判断，没必要点了全班同学的名才可以知道李刚同学来了没有。<br>根据上面的原理，首先，我们要分配一片空间用来存储我们的数据，比如是一个空的数组。<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021031418081272.png" alt="在这里插入图片描述"></p>
<p>然后，有数据存进来的时候，按照<strong>特定规则（以下规则为除11取余）</strong>得出这个数据在数组中的位置，将数据存进这个位置，我们就以存进一个整型数据为例，<strong>特定规则就是取余（即哈希函数）</strong><br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180820554.png" alt="在这里插入图片描述"></p>
<p>根据计算出来的值，将这些数据放入对应的位置，我们的数组变为<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180839529.png" alt="在这里插入图片描述"></p>
<p>我们已经把数据插入到了哈希表中，现在，我们要查找一个数据，只要按照取余规则计算出这个数据在数组中对应的位置，然后查看数组的这个位置，就可以取出这个数据了，比如我们要从哈希表中取出52，根据取余规则，52的计算出来的位置是8，数组中8这个位置是空的，52不在哈希表中，找不到52的数据；从哈希表中取出77，77计算出来的位置是0，数组中0这个位置有值，而且值就是77，从哈希表中取出77的值。<br>至此，我们知道实现了一个很简单的哈希表的原理，其实还存在很多问题，这个我们接下来讨论，这儿先把我们前面的一些概念用专业的术语替换一下，前面我们所说的<strong>特定规则</strong>，我们称之为<strong>哈希函数</strong>，用特定规则计算出来的值称之为哈希值。<br>还存在哪些问题？</p>
<ol>
<li>有可能两个数据通过哈希函数计算出来的哈希值有可能相等，比如77，88计算出来的位置值都是0</li>
<li>如果哈希表满了，该怎么扩容<br>第一个问题就是如何解决这种冲突<br>有开放定址法，链定址法，我们说一下开放定址法，就是将这个冲突的数据再重新计算一个空的位置，将其存进去，比如我们要存放88，哈希值是0，数组这个位置已经有值了，那我们再获取一个哈希值，比如在原哈希值的基础上加1，得到1，1的位置是空，我将88放进去。有人会问，1这个位置被占了，那下一个数据是1这个位置怎么办，这时候，我们还是同样的做法，给这个数据再计算一个哈希值。<br>插入88后的数组变为<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314180908886.png" alt="在这里插入图片描述"></li>
</ol>
<p>冲突解决了，但我们读取数据的时候，好像又出现问题了，88的哈希值是0，发现数组0位置不是空的，那我们确定88在哈希表中？肯定不行，0这个位置存储的是77，不是88。我们的解决方法是判断0这个位置的值是不是88，不是的话，再计算88的哈希值是1，判断是1这个位置是否为空，为空，则88不在哈希表中；不为空，判断值是否为88，若是88，确定在哈希表中；如果值不是88，我们则继续计算哈希值是2，依次下去，直到找到88或者值为空的位置。<br>第二个问题，哈希表扩容<br>一个简单的解决办法是，当插入数据时，发现所有的位置都满了，我们就再分配一个大于原先空间的一片空间，把原来空间中的值重新哈希到新的空间中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 哈希表的C实现  查找使用的方法是“除留余数法”，解决冲突使用的方法是“链地址法”。*/</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span> <span class="comment">//malloc#include &lt;string.h&gt; //memset#define FALSE 0#define TRUE 1typedef int STATUS;//定义哈希表和基本数据节点typedef struct _NODE&#123;    int data;    struct _NODE *next;&#125; NODE;typedef struct _HASH_TABLE&#123;    NODE *value[10];&#125; HASH_TABLE;//创建哈希表HASH_TABLE *create_hash_table()&#123;    HASH_TABLE *pHashTbl = (HASH_TABLE *)malloc(sizeof(HASH_TABLE));    memset(pHashTbl, 0, sizeof(HASH_TABLE));    return pHashTbl;&#125;//在哈希表中查找数据NODE *find_data_in_hash(HASH_TABLE *pHashTbl, int data)&#123;    NODE *pNode;    if (NULL == pHashTbl)        return NULL;    if (NULL == (pNode = pHashTbl-&gt;value[data % 10]))        return NULL;    while (pNode)    &#123;        if (data == pNode-&gt;data)            return pNode;        pNode = pNode-&gt;next;    &#125;    return NULL;&#125;//在哈希表中插入数据STATUS insert_data_into_hash(HASH_TABLE *pHashTbl, int data)&#123;    NODE *pNode;    if (NULL == pHashTbl)        return FALSE;    if (NULL == pHashTbl-&gt;value[data % 10])    &#123;        pNode = (NODE *)malloc(sizeof(NODE));        memset(pNode, 0, sizeof(NODE));        pNode-&gt;data = data;        pHashTbl-&gt;value[data % 10] = pNode;        return TRUE;    &#125;    if (NULL != find_data_in_hash(pHashTbl, data))        return FALSE;    pNode = pHashTbl-&gt;value[data % 10];    while (NULL != pNode-&gt;next)        pNode = pNode-&gt;next;    pNode-&gt;next = (NODE *)malloc(sizeof(NODE));    memset(pNode-&gt;next, 0, sizeof(NODE));    pNode-&gt;next-&gt;data = data;    return TRUE;&#125;//从哈希表中删除数据STATUS delete_data_from_hash(HASH_TABLE *pHashTbl, int data)&#123;    NODE *pHead;    NODE *pNode;    if (NULL == pHashTbl || NULL == pHashTbl-&gt;value[data % 10])        return FALSE;    if (NULL == (pNode = find_data_in_hash(pHashTbl, data)))        return FALSE;    if (pNode == pHashTbl-&gt;value[data % 10])    &#123;        pHashTbl-&gt;value[data % 10] = pNode-&gt;next;        free(pNode);        return TRUE;    &#125;    pHead = pHashTbl-&gt;value[data % 10];    while (pNode != pHead-&gt;next)        pHead = pHead-&gt;next;    pHead-&gt;next = pNode-&gt;next;&#125;void main()&#123;    HASH_TABLE *hashtable = create_hash_table();    insert_data_into_hash(hashtable, 1);    //insert_data_into_hash(hashtable,4);    insert_data_into_hash(hashtable, 11);    insert_data_into_hash(hashtable, 21);    NODE *node1 = find_data_in_hash(hashtable, 11);    NODE *node2 = find_data_in_hash(hashtable, 21);    printf(&quot;hashtable 1 : %d \n&quot;, hashtable-&gt;value[1]-&gt;data);    if (hashtable-&gt;value[2] == NULL)        printf(&quot;hashtable 2 is null\n&quot;);    printf(&quot;hashtable 1 : %d \n&quot;, node1-&gt;data);    printf(&quot;hashtable 1 : %d \n&quot;, node2-&gt;data);    delete_data_from_hash(hashtable, 21);    NODE *node3 = find_data_in_hash(hashtable, 21);    if (node3 == NULL)        printf(&quot;21 is cancel\n&quot;);    else        printf(&quot;hashtable 1 : %d \n&quot;, node3-&gt;data);&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-集合与映射"><a href="#4-集合与映射" class="headerlink" title="4.集合与映射"></a>4.集合与映射</h2><p>这种算法基本也是很宽泛的内容，没有具体的特定标准，具体问题需要具体分析。例如2020年的第六题（1）属于集合合并区间问题，（2）也是属于并查集问题。<br>不同的题目虽然思想来源于集合或者映射但是没有统一的代码格式，其中还会牵扯其他算法如可以用二叉树可以用图论算法等实现。用c语言也可以实现部分代码，但是最容易理解和上手的基本是c++以及java代码，因此掌握算法的求解步骤及核心思想怎么运用到实际的题目中是最关键的，至于用什么语言实现其实是次要的方面，而考试也是在考察这方面的能力，而不是过分关注你代码的语法错误或者书写能力。<br><strong>集合（Set）</strong><br>类似于栈和队列，是一种高层数据结构，往往通过实现接口来完成，底层可以选用不同的数据结构。<br>集合是一种<strong>不包含重复数据</strong>的容器，可以用于数据的去重操作<br>实现集合的关键是在添加元素时，不能包含重复元素（底层可以通过不包含重复元素的二分搜索树实现，也可以使用链表实现）<br>集合的典型应用：客户统计，词汇量统计<br><strong>映射（Map）</strong><br>高层数据结构，是存储（键，值）数据对的数据结构（Key, Value）<br>映射中的键（Key）是唯一的，可以对键所对应的值作修改<br>映射中的Key就相当于集合中存放的元素，只不过映射中的Key还跟着一个Value<br>可以根据键（Key），快速寻找值（Value）<br>（当然你可以用struct结构体来构建对应的链表和二叉树）<br> <img src="https://img-blog.csdnimg.cn/20210314181022479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5.图"></a>5.图</h2><p>了解下以下一些关于图的概念，图的范围太广了，同时这些概念也适用于12动态规划、13搜索、14图论算法章节。没必要所有概念思想都弄明白，如果都明白了那你就可以去考清华的计算机了。<br><strong>图的定义：</strong> 图（graph）是由一些点（vertex）和这些点之间的连线（edge）所组成的；其中，点通常称为顶点（vertex），而点到点之间的连线通常称之为边或者弧（edge）。通常记为G=（V,E）。<br><strong>图的种类：</strong> 根据边是否有方向，将图可以划分为：无向图和有向图。<br>无向图：下面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，<br>(01)V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。<br>(02)E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181214653.png" alt="加粗样式"></p>
<p>有向图：<br>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中， V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。<br>A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点C”的有向边。<br>**邻接点：**<br>一条边上的两个顶点叫做邻接点。例如，上面无向图G0中的顶点A和顶点C就是邻接点。在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。例如，上面有向图G2中的B和E是邻接点；&lt;B,E&gt;是B的出边，还是E的入边。<br><strong>度：</strong><br>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。例如，上面无向图G0中顶点A的度是2。在有向图中，度还有”入度”和”出度”之分。某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。顶点的度=入度+出度。例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。<br><strong>路径：</strong> 如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br><strong>路径长度：</strong> 路径中”边的数量”。<br><strong>简单路径：</strong> 若一条路径上顶点不重复出现，则是简单路径。<br><strong>回路：</strong> 若路径的第一个顶点和最后一个顶点相同，则是回路。<br><strong>简单回路：</strong> 第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。<br><strong>连通图：</strong> 对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。<br><strong>连通分量：</strong> 非连通图中的各个连通子图称为该图的连通分量。<br><strong>权：</strong> 在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似，如下图G3.<br> <img src="https://img-blog.csdnimg.cn/20210314181342435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>图的存储：</strong><br>下面开始介绍图的存储结构。图的存储结构，常用的是“邻接矩阵”和“邻接表”。<br><strong>邻接矩阵</strong>是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。<br>假设图中顶点数为n，则邻接矩阵定义为：<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181405768.png" alt="在这里插入图片描述"></p>
<p>下面通过示意图来进行解释。<br> <img src="/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210314181412222.png" alt="在这里插入图片描述"></p>
<p>图中的G1是无向图和它对应的邻接矩阵。<br>上面的图G1包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了”(A,C),(A,D),(A,F),(B,C),(C,D),(E,G),(F,G)”共7条边。由于这是无向图，所以边(A,C)和边(C,A)是同一条边；这里列举边时，是按照字母先后顺序列举的。<br>上图右边的矩阵是G1在内存中的邻接矩阵示意图。A[i][j]=1表示第i个顶点与第j个顶点是邻接点，A[i][j]=0则表示它们不是邻接点；而A[i][j]表示的是第i行第j列的值；例如，A[1,2]=1，表示第1个顶点(即顶点B)和第2个顶点(C)是邻接点。<br>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵typedef struct _graph&#123;    char vexs[MAX];       // 顶点集合    int vexnum;           // 顶点数    int edgnum;           // 边数    int matrix[MAX][MAX]; // 邻接矩阵&#125; Graph, *PGraph;/*Graph是邻接矩阵对应的结构体。 vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示&quot;顶点i(即vexs[i])&quot;和&quot;顶点j(即vexs[j])&quot;是邻接点；matrix[i][j]=0，则表示它们不是邻接点。*//* * 创建图(用已提供的矩阵) */Graph *create_example_graph()&#123;    char vexs[] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;&#125;;    char edges[][2] = &#123;        &#123;&#x27;A&#x27;, &#x27;C&#x27;&#125;,        &#123;&#x27;A&#x27;, &#x27;D&#x27;&#125;,        &#123;&#x27;A&#x27;, &#x27;F&#x27;&#125;,        &#123;&#x27;B&#x27;, &#x27;C&#x27;&#125;,        &#123;&#x27;C&#x27;, &#x27;D&#x27;&#125;,        &#123;&#x27;E&#x27;, &#x27;G&#x27;&#125;,        &#123;&#x27;F&#x27;, &#x27;G&#x27;&#125;&#125;;    int vlen = LENGTH(vexs);    int elen = LENGTH(edges);    int i, p1, p2;    Graph *pG;    // 输入&quot;顶点数&quot;和&quot;边数&quot;    if ((pG = (Graph *)malloc(sizeof(Graph))) == NULL)        return NULL;    memset(pG, 0, sizeof(Graph));    // 初始化&quot;顶点数&quot;和&quot;边数&quot;    pG-&gt;vexnum = vlen;    pG-&gt;edgnum = elen;    // 初始化&quot;顶点&quot;    for (i = 0; i &lt; pG-&gt;vexnum; i++)    &#123;        pG-&gt;vexs[i] = vexs[i];    &#125;    // 初始化&quot;边&quot;    for (i = 0; i &lt; pG-&gt;edgnum; i++)    &#123;        // 读取边的起始顶点和结束顶点        p1 = get_position(*pG, edges[i][0]);        p2 = get_position(*pG, edges[i][1]);        pG-&gt;matrix[p1][p2] = 1;        pG-&gt;matrix[p2][p1] = 1;    &#125;    return pG;&#125;</span></span><br></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20210314181550983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>图中的G2是无向图和它对应的邻接矩阵。<br>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。<br>邻接矩阵的缺点就是比较耗费空间。</p>
<p>邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。<br> <img src="https://img-blog.csdnimg.cn/20210314181603552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>图中的G1是无向图和它对应的邻接矩阵。<br> <img src="https://img-blog.csdnimg.cn/2021031418161257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>图中的G2是无向图和它对应的邻接矩阵。上面的图G2包含了”A,B,C,D,E,F,G”共7个顶点，而且包含了<br>“&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;B,F&gt;,&lt;C,E&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;E,D&gt;,&lt;F,G&gt;”共9条边。<br>上图右边的矩阵是G2在内存中的邻接表示意图。每一个顶点都包含一条链表，该链表记录了”该顶点所对应的出边的另一个顶点的序号”。例如，第1个顶点(顶点B)包含的链表所包含的节点的数据分别是”2,4,5”；而这”2,4,5”分别对应”C,E,F”的序号，”C,E,F”都属于B的出边的另一个顶点。<br><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表中表对应的链表的顶点typedef struct _ENode&#123;    int ivex;                 // 该边所指向的顶点的位置    struct _ENode *next_edge; // 指向下一条弧的指针&#125; ENode, *PENode;// 邻接表中表的顶点typedef struct _VNode&#123;    char data;         // 顶点信息    ENode *first_edge; // 指向第一条依附该顶点的弧&#125; VNode;// 邻接表typedef struct _LGraph&#123;    int vexnum; // 图的顶点的数目    int edgnum; // 图的边的数目    VNode vexs[MAX];&#125; LGraph;/*(01) LGraph是邻接表对应的结构体。vexnum是顶点数，edgnum是边数；vexs则是保存顶点信息的一维数组。(02) VNode是邻接表顶点对应的结构体。data是顶点所包含的数据，而first_edge是该顶点所包含链表的表头指针。(03) ENode是邻接表顶点所包含的链表的节点对应的结构体。ivex是该节点所对应的顶点在vexs中的索引，而next_edge是指向下一个节点的。*//* * 创建邻接表对应的图(自己输入) */LGraph *create_lgraph()&#123;    char c1, c2;    int v, e;    int i, p1, p2;    ENode *node1, *node2;    LGraph *pG;    // 输入&quot;顶点数&quot;和&quot;边数&quot;    printf(&quot;input vertex number: &quot;);    scanf(&quot;%d&quot;, &amp;v);    printf(&quot;input edge number: &quot;);    scanf(&quot;%d&quot;, &amp;e);    if (v &lt; 1 || e &lt; 1 || (e &gt; (v * (v - 1))))    &#123;        printf(&quot;input error: invalid parameters!\n&quot;);        return NULL;    &#125;    if ((pG = (LGraph *)malloc(sizeof(LGraph))) == NULL)        return NULL;    memset(pG, 0, sizeof(LGraph));    // 初始化&quot;顶点数&quot;和&quot;边数&quot;    pG-&gt;vexnum = v;    pG-&gt;edgnum = e;    // 初始化&quot;邻接表&quot;的顶点    for (i = 0; i &lt; pG-&gt;vexnum; i++)    &#123;        printf(&quot;vertex(%d): &quot;, i);        pG-&gt;vexs[i].data = read_char();        pG-&gt;vexs[i].first_edge = NULL;    &#125;    // 初始化&quot;邻接表&quot;的边    for (i = 0; i &lt; pG-&gt;vexnum; i++)    &#123;        // 读取边的起始顶点和结束顶点        printf(&quot;edge(%d): &quot;, i);        c1 = read_char();        c2 = read_char();        p1 = get_position(*pG, c1);        p2 = get_position(*pG, c2);        // 初始化node1        node1 = (ENode *)malloc(sizeof(ENode));        node1-&gt;ivex = p2;        // 将node1链接到&quot;p1所在链表的末尾&quot;        if (pG-&gt;vexs[p1].first_edge == NULL)            pG-&gt;vexs[p1].first_edge = node1;        else            link_last(pG-&gt;vexs[p1].first_edge, node1);        // 初始化node2        node2 = (ENode *)malloc(sizeof(ENode));        node2-&gt;ivex = p1;        // 将node2链接到&quot;p2所在链表的末尾&quot;        if (pG-&gt;vexs[p2].first_edge == NULL)            pG-&gt;vexs[p2].first_edge = node2;        else            link_last(pG-&gt;vexs[p2].first_edge, node2);    &#125;    return pG;&#125;/*create_lgraph()是读取用户的输入，将输入的数据转换成对应的无向图。*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-排序"><a href="#6-排序" class="headerlink" title="6.排序"></a>6.排序</h2><h3 id="（1）冒泡排序"><a href="#（1）冒泡排序" class="headerlink" title="（1）冒泡排序"></a>（1）冒泡排序</h3><p>冒泡排序在一组需要排序的数组中，对两两数据顺序与要求顺序相反时，交换数据，使大的数据往后移，每趟排序将最大的数放在最后的位置上，如下：<br> <img src="https://img-blog.csdnimg.cn/20210314181717477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i, j, tmp;    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)    &#123;        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; n; j++)        &#123;            <span class="keyword">if</span>(arr[j] &lt; arr[j - <span class="number">1</span>])            &#123;                tmp = arr[j];                arr[j] = arr[j - <span class="number">1</span>];                arr[j - <span class="number">1</span>] = tmp;            &#125;        &#125;    &#125;&#125;<span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i;    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);    &#125;    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);&#125;<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;    printArray(arr, <span class="number">10</span>);    bubbleSort(arr, <span class="number">10</span>);    printArray(arr, <span class="number">10</span>);    <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>如上是一种最简单的实现方式，需要注意的可能是i, j的边界问题，这种方式固定循环次数，肯定可以解决各种情况，不过算法的目的是为了提升效率，根据冒泡排序的过程图可以看出这个算法至少可以从两点进行优化：<br>1)对于外层循环，如果当前序列已经有序，即不再进行交换，应该不再进行接下来的循环直接跳出。<br>2)对于内层循环后面最大值已经有序的情况下应该不再进行循环。<br>优化代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort_1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i, nflag, tmp;    <span class="keyword">do</span>    &#123;        nflag = <span class="number">0</span>;        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)        &#123;            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])            &#123;                tmp = arr[i];                arr[i] = arr[i + <span class="number">1</span>];                arr[i + <span class="number">1</span>] = tmp;                nflag = i + <span class="number">1</span>;            &#125;        &#125;        n = nflag;    &#125;<span class="keyword">while</span>(nflag);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>选择排序是最简单的一种基于O（n2）时间复杂度的排序算法，基本思想是从i=0位置开始到i=n-1每次通过内循环找出i位置到n-1位置的最小（大）值。<br> <img src="https://img-blog.csdnimg.cn/2021031418175728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i, j , minValue, tmp;    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)    &#123;        minValue = i;        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)        &#123;            <span class="keyword">if</span>(arr[minValue] &gt; arr[j])            &#123;                minValue = j;            &#125;        &#125;        <span class="keyword">if</span>(minValue != i)        &#123;            tmp = arr[i];            arr[i] = arr[minValue];            arr[minValue] = tmp;        &#125;    &#125;&#125;<span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i;    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);    &#125;    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);&#125;<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;    printArray(arr, <span class="number">10</span>);    selectSort(arr, <span class="number">10</span>);    printArray(arr, <span class="number">10</span>);    <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）快速"><a href="#（3）快速" class="headerlink" title="（3）快速"></a>（3）快速</h3><p>快速排序跟归并排序类似属于分治法的一种，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>排序过程如图：<br> <img src="https://img-blog.csdnimg.cn/20210314181816810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>因此，快速排序每次排序将一个序列分为两部分，左边部分都小于等于右边部分，然后在递归对左右两部分进行快速排序直到每部分元素个数为1时则整个序列都是有序的，因此快速排序主要问题在怎样将一个序列分成两部分，其中一部分所有元素都小于另一部分，对于这一块操作我们叫做partition,原理是先选取序列中的一个元素做参考量，比它小的都放在序列左边，比它大的都放在序列右边。<br>该方法的基本思想是：<br>1．先从数列中取出一个数作为基准数。<br>2．分区，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br>6，1，2，7，9，3，4，5，10，8<br>第一轮：standard=6，<em>startIndex=6，</em>endIndex=8，<em>leftIndex=6，</em>rightIndex=8<br>**6&lt;8成立，则rightIndex从后往前移动**，直到小于6为止，即rightIndex指向数值为5的下标<br>将5的值赋值到leftIndex的位置，此时righIndex的位置空出来，那么从前往后找比standard大的数放在空出的位置<br>当leftIndex=7的时候符合，则将leftIndex的赋值给rightIndex<br>此时5，1，2，7，9，3，4，7，10，8，继续while循环，直到leftIndex&gt;=rightIndex结束，最后5，1，2，4，3，9，9，7，10，8<br>While循环后：将9的位置也就是leftIndex填补成基础standard=6，即下一轮分别单独排6左侧和右侧的数组<br>最后5，1，2，4，3，6，9，7，10，8<br>即6左侧为比6小的，右侧比6大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>int *boundary(int array[], int *startIndex, int *endIndex)&#123;    int standard = *startIndex;  <span class="comment">// 基数    int *leftIndex = startIndex; // 从前往后的数    int *rightIndex = endIndex;  // 从后往前的数    while (leftIndex &lt; rightIndex)    &#123;        while (leftIndex &lt; rightIndex &amp;&amp; *rightIndex &gt;= standard)        &#123;            rightIndex--; //从后往前找到比基数小的数放在基数的左侧        &#125;        *leftIndex = *rightIndex; //填补从后往前的空位置        while (leftIndex &lt; rightIndex &amp;&amp; *leftIndex &lt;= standard)        &#123;            leftIndex++; //从前往后找到比基数小的数放在基数的右侧        &#125;        *rightIndex = *leftIndex;    &#125;    *leftIndex = standard; //基数填补位置，下一轮从leftIndex的位置开始，即    return leftIndex;&#125;void quicksort(int array[], int *startIndex, int *endIndex)&#123;    //每一轮结束的标志是从前往后的下标大于等于从后往前的下标    if (startIndex &gt;= endIndex)    &#123;        return;    &#125;    int *boundary = boundary(array, startIndex, endIndex);    quicksort(array, startIndex, boundary - 1); //按照第一轮的方法继续排左侧的数组    quicksort(array, boundary + 1, endIndex);   //按照第一轮的方法继续排右侧的数组&#125;int main()&#123;    int array[] = &#123;6, 1, 2, 7, 9, 3, 4, 5, 10, 8&#125;;    int *startIndex = array;   //基数默认从第0个位置    int *endIndex = &amp;array[9]; //先从后往前，再从前往后找    quicksort(array, startIndex, endIndex);    for (int i = 0; i &lt; 10; i++)        printf(&quot;%d &quot;, array[i]);&#125;return 0；&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="希尔"><a href="#希尔" class="headerlink" title="希尔"></a>希尔</h3><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量</strong>排序。希尔排序的基本思想是先取一个小于n的整数d1作为第一个增量，把全部元素分组。左右距离为d1的倍数的记录放在同一组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1（&lt;•••&lt;d2&lt;d1）,即所有记录放在同一组中进行直接插入排序为止，希尔排序主要是根据插入排序的以下两种性质对插入排序进行改进：</p>
<ol>
<li>插入排序在对几乎<strong>已经排好序</strong>的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为<strong>插入排序每次只能将数据移动一位</strong></li>
</ol>
<p> <img src="https://img-blog.csdnimg.cn/20210314182007330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>排序过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;	<span class="keyword">int</span> i, j, elem;	<span class="keyword">int</span> k = n/<span class="number">2</span>;<span class="comment">//希尔增量，一般是一半，可以更改;	while（k&gt;=1）	&#123;		for (i = k; i &lt; n; i++)		&#123;			elem = arr[i];			for(j = i; j &gt;= k; j-=k)			&#123;				if(elem&lt;arr[j-k])				&#123;					arr[j] = arr[j-k];				&#125;				else				&#123;					break;				&#125;			&#125;			arr[j] = elem;		&#125;		k = k/2;//增量减小一半	&#125;&#125;void printArray(int arr[],int n)&#123;	int i;	for(i = 0; i &lt; n; i++)	&#123;		printf(&quot;%d &quot;,arr[i]);	&#125;	printf(&quot;\n&quot;);	return;&#125;void main()&#123;	int arr[10] = &#123;2,5,6,4,3,7,9,8,1,0&#125;;	printArray(arr,10);	shellSort(arr,10);	printArray(arr,10);	return;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）插入"><a href="#（5）插入" class="headerlink" title="（5）插入"></a>（5）插入</h3><p>插入排序是将一个记录插入到已经有序的序列中，得到一个新的元素加一的有序序列，实现上即将第一个元素看成一个有序的序列，从第二个元素开始逐个插入得到一个完整的有序序列，插入过程如下：<br> <img src="https://img-blog.csdnimg.cn/2021031418203791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;    <span class="keyword">int</span> i, j, tmp;    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//将下标0的元素看成一个有序的序列    &#123;        for(j = i; j &gt; 0; j--)        &#123;            if(arr[j] &lt; arr[j-1])            &#123;                tmp = arr[j];                arr[j] = arr[j-1];                arr[j-1] = tmp;            &#125;            else            &#123;                break;            &#125;        &#125;    &#125;    return;&#125;void printArray(int arr[], int n)&#123;    int i;    for(i = 0; i &lt; n; i++)    &#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\n&quot;);    return;&#125;void main()&#123;    int arr[10] = &#123;2,5,6,4,3,7,9,8,1,0&#125;;    printArray(arr, 10);    insertSort(arr, 10);    printArray(arr, 10);    return;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>改编：2013-4-1</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>int main()&#123;    int i, j, k, a[11] = &#123;0, 8, 3, 2, 9, 5, 6, 4, 1, 10, 7&#125;;    for (i = 2; i <span class="meta-string">&lt; 11; i++)    &#123;        a[0] = a[i];        j = i - 1;        while (a[j] &gt;</span> a[0])        &#123;            a[j + 1] = a[j];            j--;        &#125;        a[j + 1] = a[0];    &#125;    for (i = 1; i &lt; 11; i++)        printf(<span class="meta-string">&quot;%d &quot;</span>, a[i]);    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）归并"><a href="#（6）归并" class="headerlink" title="（6）归并"></a>（6）归并</h3><p>归并排序是基于归并操作的一种排序算法，归并操作的原理就是将一组有序的子序列合并成一个完整的有序序列，即首先需要把一个序列分成多个有序的子序列，通过分解到每个子序列只有一个元素时，每个子序列都是有序的，在通过归并各个子序列得到一个完整的序列。<br> <img src="https://img-blog.csdnimg.cn/20210314182129124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>合并过程：<br>把序列中每个单独元素看作一个有序序列，每两个单独序列归并为一个具有两个元素的有序序列，每两个有两个元素的序列归并为一个四个元素的序列依次类推。两个序列归并为一个序列的方式：因为两个子序列都是有序的（假设由小到大），所有每个子序列最左边都是序列中最小的值，<strong>整个序列最小值只需要比较两个序列最左边的值</strong>，所以归并的过程不停取子序列最左边值中的最小值放到新的序列中，两个子序列值取完后就得到一个有序的完整序列。<br><strong>递归实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>void MergeArr(int *src,int *temp,int start,int mid,int end)&#123;    int i=start;	int j=mid+1;    int k=start;    while(i!=mid +1 &amp;&amp; j!=end + 1)<span class="comment">//并    &#123;        if(src[i]&lt;src[j])            temp[k++]=src[i++];        else            temp[k++]=src[j++];    &#125;	if(i==mid+1)	&#123;		while(j!=end+1)			tmp[k++]=src[j++];	&#125;	else	&#123;    while(i!=mid+1)        temp[k++]=src[i++];	&#125;    while(start&lt;=end)    &#123;        src[start]=tmp[start];		start++;    &#125;&#125;//一定要联系快速排序，都是分治策略void MegerSort(int *arr,int *tmp,int start,int end)  //归&#123;    if(start&lt;end)    &#123;        int mid=(start+end)/2;        MergeSort(arr,tmp,start,mid);//左边        MergeSort(arr,tmp,mid+1,end);//右边        MergeArr(arr,tmp,start,mid,end);//合并    &#125;&#125;int main()&#123;    int a[8]=&#123;2,4,5,9,1,6,7,8&#125;;    int c[8]=&#123;0&#125;;//合并后的数组	MergeSort(a,c,0,7);    for(int i=0;i&lt;8;i++)    &#123;        printf(&quot;%d\t&quot;,c[i]);    &#125;    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-查找"><a href="#7-查找" class="headerlink" title="7.查找"></a>7.查找</h2><h3 id="（1）折半查找"><a href="#（1）折半查找" class="headerlink" title="（1）折半查找"></a>（1）折半查找</h3><p>又名二分查找：c课本习题及历年真题均有考察，算是比较简单的代码。这里不再浪费纸质资源。注意N个元素最大查找次数：Log<sub>2</sub>  N=？，如110个元素，最大比较次数为7次。</p>
<blockquote>
<p><strong>2016第五大题程序填空</strong>：<br>函数bi_serach 是一个使用“折半查找法”在长度为n(n&gt;=1)的一维有序（从小到大）数组a 中查找指定数据x 的子函数，若找到，函数返回该数据在数组中的下标；否则返回-1，请仔细阅读下面的程序并补充完整。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123;    <span class="keyword">int</span> bot = <span class="number">0</span>, mid, top = n - <span class="number">1</span>, find = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        mid = (bot + top) / <span class="number">2</span>;<span class="keyword">if</span>(a[mid]==x])    find = <span class="number">1</span>;<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)    top = mid - <span class="number">1</span>;<span class="keyword">else</span>    bot = mid + <span class="number">1</span>;    &#125; <span class="keyword">while</span> (bot &lt;= top &amp;&amp; find == <span class="number">0</span>);    <span class="keyword">if</span> (find)        <span class="keyword">return</span> (mid);    <span class="keyword">else</span>        <span class="keyword">return</span> (<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>其他查找基本不会考感觉，但是想练一下的可以试试：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/maybe2030/p/4715035.html#_label3">https://www.cnblogs.com/maybe2030/p/4715035.html#_label3</a></p>
<h2 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h2><p>[穷举，区分enum关键字]<br>枚举基本很简单，就是暴力破解，历年真题均有考察，如2017年的第五大题程序填空小偷问题，2020第一大题填空台阶问题，基本就是在列举所有出现的情况。<br>枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。在C语言中，枚举算法一般使用while循环实现。使用枚举算法解题的基本思路如下所示：<br>（1）确定枚举对象、枚举范围和判定条件。<br>（2）逐一枚举可能的解，验证每个解是否是问题的解。<br>枚举算法一般按照如下3个步骤进行：<br>（1）题解的可能范围，不能遗漏任何一个真正解，也要避免有重复。<br>（2）判断是否是真正解的方法。<br>（3）使可能解的范围降至最小，以便提高解决问题的效率。<br>用一个例子说明枚举算法的思想：<br>百钱买百鸡问题：公鸡每只5元，母鸡每只3元，小鸡每3只1元。用100元钱买100只鸡，问公鸡、母鸡、小鸡各多少钱？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>int main()&#123;    int x, y, z;                  <span class="comment">//三个变量分别为公鸡、母鸡、小鸡的数量    for (x = 0; x &lt;= 20; x++)     //公鸡最多20只    &#123;        for (y = 0; y &lt;= 33; y++) //母鸡最多33只        &#123;            z = 100 - x - y;      //小鸡的数量            if (z % 3 == 0 &amp;&amp; (x * 5 + y * 3 + z / 3 == 100)) //小鸡3元一只，所以小鸡数量应该是3的倍数                printf(&quot;公鸡%d只,母鸡%d只,小鸡%d只\n&quot;, x, y, z);        &#125;    &#125;        return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="9-贪心策略"><a href="#9-贪心策略" class="headerlink" title="9.贪心策略"></a>9.贪心策略</h2><p>贪心算法是一种在解决问题的过程中追求局部最优的算法，对于一个有多种属性的事物来说，贪心算法会优先满足某种条件，追求局部最优的同时希望达到整体最优的效果。<br>以背包问题为例，可以放在背包中的物体有它的重量和价值两种属性，背包的容量也是有限的，我们希望得到一种价值最大的物品摆放方式，如果我们倾向于重量贪心，那么在摆放物品的时候会优先放重量小的，但这和我们追求的价值最优没有关系，自然不能采用；如果倾向于价值贪心，而忽略了物品的重量，可能会导致摆放物品的数量不多，总价值很小；如果是以价值和重量的比值设计贪心算法求解，便可以实现最优的方案。下面我们举一些例子来说明在实际运用中如何实践贪心算法。</p>
<h3 id="（1）钱币找零问题"><a href="#（1）钱币找零问题" class="headerlink" title="（1）钱币找零问题"></a>（1）钱币找零问题</h3><p>[这个问题挺适合在代码填空中去考]<br>1、题目：指定币值和相应的数量，用最少的数量凑齐某金额。<br>2、思路：利用贪心算法，我们优先选择面值大的钱币，以此类推，直到凑齐总金额。<br>int values[] = { 1, 2, 5, 10, 20, 50, 100 };//数量<br>int counts[] = { 3, 3, 2, 1, 1, 3, 3 };//获取需要各种面值多少张<br>int <em>result = getNumber1(446, values, counts);<br>int</em> getNumber1(int sum , int values[], int counts[])<br>{<br>    int result[7] = {0};<br>    int add=0; //当前凑的金额<br>    for(int i=(sizeof(values)/4)-1;i&gt;=0;i–)<br>    {<br>        int num = (sum-add)/values[i];<br>        if(num&gt;counts[i])<br>        {<br>            num=counts[i];<br>        }<br>        add=add+num*values[i];<br>        result[i]=num;<br>    }<br>    return result;<br>}</p>
<h3 id="（2）活动选择问题"><a href="#（2）活动选择问题" class="headerlink" title="（2）活动选择问题"></a>（2）活动选择问题</h3><p>题目： 有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi ，一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天，该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。</p>
<p>2、思路：使用贪心算法，目标是实现安排尽可能多的活动，那么我们优先找那些结束时间早的活动，为后面的活动留出更多时间，即以结束时间为贪心。<br>3、算法实现：<br>注：这里我们稍打乱了顺序，在代码中采用了插入排序的方法对数据简单整理，使得结束时间从小到大排列。<br>int st[] = {1,5,0,5,3,3,6,8,8,2,12};<br>int et[] = {4,9,6,7,8,5,10,12,11,13,14};<br>int num = getNumber2(st,et);</p>
<p>int getNumber2(int a[] , int b[])  //优先选择结束时间早的<br>{<br>    int num=0;<br>    int tempa=0;<br>    int tempb=0;<br>    int endTime=0;<br>    int j=0;<br>    for(int i=1;i&lt;sizeof(b);i++)//如果顺序混乱，则调整为结束时间从小到大的顺序,直接插入排序<br>    {<br>        tempb=b[i];<br>        tempa=a[i];<br>        for(j=i-1;j&gt;=0&amp;&amp;tempb&lt;b[j];j–)<br>        {<br>            b[j+1]=b[j];<br>            a[j+1]=a[j];<br>            if(j==0)<br>            {<br>                j–;<br>                break;<br>            }<br>        }<br>        b[j+1]=tempb;<br>        a[j+1]=tempa;<br>    }<br>    printf(“for循环分别输出数组a和b”)<br>        num++;<br>    endTime=b[0];     //b[0]结束时间最早<br>    for(int k=1;k&lt;sizeof(b);k++)<br>    {<br>        if(a[k]&gt;endTime)  //开始时间大于最早的结束时间则表示此课可以排在后面<br>        {<br>            num++;<br>            endTime=b[k];    //记录结束时间<br>        }<br>    }<br>    return num;        //返回最多任务数（课程数）<br>    }<br>}</p>
<h3 id="（3）背包问题"><a href="#（3）背包问题" class="headerlink" title="（3）背包问题"></a>（3）背包问题</h3><p>1、题目：现有几种拥有一定重量和价值两个属性的物品，需要放到一个容量一定（能承受的重量一定）的包中，物品放入包中时，物品可以不完全放入包中，而放入一部分，求价值最大的方案。<br>2、思路： 背包问题一般不能使用贪心算法。 然而我们考虑这样一种背包问题：在选择物品i装入背包时，可以选择物品的一部分，而不一定要全部装入背包。这时便可以使用贪心算法求解了。 计算每种物品的单位重量价值作为贪心选择的依据指标，选择单位重量价值最高的物品，将尽可能多的该物品装入背包，依此策略一直地进行下去，直到背包装满为止。 在零一背包问题中贪心选择之所以不能得到最优解原因是贪心选择无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。 在程序中已经事先将单位重量价值按照从大到小的顺序排好。<br>3、算法实现：<br>void greedy3()<br>{<br>    float M=50;  //背包所能容纳的重量<br>    float[] w={0,10,30,20,5};  //每种物品的重量<br>    float[] v={0,200,400,450,20};    //每种物品的价值<br>    float num = getNumber3(M,w,v);<br>    printf(“物品数量：%d”,num);<br>}</p>
<p>float getNumber3(float M,float w[] ,float v[])<br>{<br>    float num=0;<br>    int i=0;<br>    float max=0;<br>    float weight=0;<br>    for(i=0;i&lt;sizeof(w);i++)<br>    {<br>        if(v[i]/w[i]&gt;max)<br>        {<br>            max=v[i]/w[i];<br>            weight=w[i];<br>        }<br>    }<br>    num=M/weight;<br>    return num;<br>}</p>
<h3 id="（4）多机调度问题"><a href="#（4）多机调度问题" class="headerlink" title="（4）多机调度问题"></a>（4）多机调度问题</h3><p>1、题目：n个作业组成的作业集，可由m台相同机器加工处理。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。<br>2、思路：作业不能拆分成更小的子作业；每个作业均可在任何一台机器上加工处理。 这个问题是NP完全问题，还没有有效的解法(求最优解)，但是可以用贪心选择策略设计出较好的近似算法(求次优解)。当n&lt;=m时，只要将作业时间区间分配给作业即可；当n&gt;m时，首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，把它分配给当前总累计需要工作时长最短的机器。这样一来，这个调度问题可以理解为一个分配问题，我们通过这种方案，使得几台机器获得接近的工作总时长，达到整体的最短的工作时长的效果。<br>3、算法实现：<br>void greedy4()<br>{<br>    int time[]= {9,7,8,4,2,1,3};//作业时间<br>    int number = 3;//3台机器<br>    int Sumtime = getNumber4(time,number);<br>    printf(“花费的最小总时间：%d”,Sumtime);<br>}<br>int getNumber4(int time[], int number)<br>{<br>    int usedTime=0;  //最长时间为总时间<br>    int fin[number]; //单机处理时间<br>    for(int k=0;k&lt;number;k++) //初始时间清零<br>    {<br>        fin[k]=0;<br>    }<br>    if(number&gt;sizeof(time))<br>        return time[0];<br>    else<br>    {<br>        for( int i=0 ; i&lt;(sizeof(time))-1 ;i++)<br>        {<br>            for( int j=0;j&lt;(sizeof(time))-i-1;j++) //冒泡选出任务时间最大的<br>            {<br>                if(time[j]&gt;time[j+1])<br>                {<br>                    int temp = time[j+1];<br>                    time[j+1]=time[j];<br>                    time[j]=temp;<br>                }<br>            }<br>            int min=0;;<br>            int value=100;<br>            for(int k=0;k&lt;fin.length;k++)  //选出当前累计工时最小的机子<br>            {<br>                if(fin[k]&lt;value)<br>                {<br>                    min=k;<br>                    value=fin[k];<br>                }<br>            }<br>            fin[min]+=time[(sizeof(time))-1-i];<br>        }<br>        int min=0;;<br>        int value=100;<br>        for(int k=0;k&lt;sizeof(fin);k++)  //选出当前累计工时最小的机子<br>        {<br>            if(fin[k]&lt;value)<br>            {<br>                min=k;<br>                value=fin[k];<br>            }<br>        }<br>        fin[min]+=time[0];<br>        for( int n=0;n&lt;sizeof(fin);n++)<br>        {<br>            if(fin[n]&gt;usedTime)<br>            {<br>                usedTime=fin[n];<br>            }<br>        }<br>        return usedTime;<br>    }<br>}</p>
<h3 id="（5）小船过河问题"><a href="#（5）小船过河问题" class="headerlink" title="（5）小船过河问题"></a>（5）小船过河问题</h3><p>1、题目：N个人过河，船每次只能坐两个人，船载每个人过河的所需时间不同t[i]，每次过河的时间为船上的人的较慢的那个，求最快的过河时间。(船划过去要有一个人划回来)<br>2、思路：本题的最优选择是先将所有人过河所需的时间按照升序排序。优先把速度慢的人带到对岸，返回由速度快的人来完成，节省时间，在剩余人数大于3时，有两种方式： 1.最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，所需时间为：t[0]+2t[1]+t[n-1]；2.最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，所需时间为：2t[0]+t[n-2]+t[n-1]。最后还需处理一下人数小于等于3的边界问题。<br>3、算法实现：<br>void greedy5()<br>{<br>    int v[] = {1,3,4,8,4,3,9}; //按照不同的人的速度过河所需的时间<br>    int timeSum=getNumber5(v);<br>    printf(“过河总时间：%d”,timeSum);<br>}</p>
<p>int getNumber5(int v[])<br>{<br>    int time =0;;<br>    Arrays.sort(v);//降序排列(最好自己选一个排序算法写一下)<br>    int N = sizeof(v); //N表示当前人数<br>    while(N&gt;3)<br>    {<br>        //两种不同方式下时间对比，哪个用时短用哪个<br>        if(2<em>v[0]+v[N-1]+v[N-2]&gt;2</em>v[1]+v[0]+v[N-1])<br>            time+=2<em>v[1]+v[0]+v[N-1];<br>        else<br>            time+=2</em>v[0]+v[N-1]+v[N-2];<br>        N-=2;<br>    }<br>    else if(N==3) //处理边界<br>    {<br>        time+=v[2]+v[0]+v[1];//要折回<br>    }<br>    else if(N==2)<br>    {<br>        time+=v[1];//两个人看最慢的时间<br>    }<br>    else if(N==1)<br>    {<br>        time+=v[0];<br>    }<br>    return time;<br>}</p>
<h2 id="10-分治策略"><a href="#10-分治策略" class="headerlink" title="10.分治策略"></a>10.分治策略</h2><p>分治法是一种很重要的算法，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题••••••知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），汉诺塔都是历年真题考过的思想。<br>分治算法可以求解的一些经典问题。<br>二分搜索<br>大整数乘法<br>棋盘覆盖<br>合并排序<br>快速排序<br>线性时间选择<br>最接近点对问题<br>循环赛日程表<br>汉诺塔<br>分治算法的基本步骤<br>分治法在每一层递归上都有三个步骤：<br>1）分解：将原问题分解成若干个规模较小，相互独立，与原问题形式相同的子问题<br>2）解决：若干个子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>3）合并：将各个子问题的解合并为原问题的解<br>（1）汉诺塔<br>详见谭浩强c语言课本函数章节有关汉诺塔的解析，下面大题说下过程：<br>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上(可以借助第三根柱子做缓冲)。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。<br>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p>
<p>（1）n == 1<br>第1次  1号盘  A—-&gt;C       sum = 1 次<br> (2) n == 2<br>第1次  1号盘  A—-&gt;B<br>第2次  2号盘  A—-&gt;C<br>第3次  1号盘  B—-&gt;C        sum = 3 次<br>（3）n == 3<br>第1次 1号盘 A—-&gt;C<br>第2次 2号盘 A—-&gt;B<br>第3次 1号盘 C—-&gt;B<br>第4次 3号盘 A—-&gt;C<br>第5次 1号盘 B—-&gt;A<br>第6次 2号盘 B—-&gt;C<br>第7次 1号盘 A—-&gt;C          sum = 7 次<br>不难发现规律：<br>1个圆盘的次数 2的1次方减1<br>2个圆盘的次数 2的2次方减1<br>3个圆盘的次数 2的3次方减1<br>。  。   。    。   。<br>n个圆盘的次数 2的n次方减1<br>故：移动次数为：2^n – 1<br>实现这个算法可以简单分为三个步骤：<br>（1）把n-1个盘子由A移到B；<br>（2）把第n个盘子由A移到C；<br>（3）把n-1个盘子由B移到C；<br>从这里入手，在加上上面数学问题解法的分析，我们不难发现，移动的步数必定为奇数步：<br>（1）中间的一步是把最大的一个盘子由A移到C上去；<br>（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上；<br>（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；<br>问题1：（2018-4-2）分析以下题目的输出。（具体代码可以看C课本函数章节）<br>#include &lt;stdio.h&gt;<br>#define L 8<br>#define M 5<br>#define T 3<br>static int n;<br>void move(char x,char y)<br>{<br>printf(“%c–%c\t”,x,y);<br>if(++n%5==0)<br>{<br>putchar(‘\n’);<br>}<br>}<br>void divide(int a,int b,int c)<br>{<br>int t;<br>if(a!=L/2)<br>{<br>if(b==0)<br>{<br>move(‘A’,’B’);<br>divide(a-M,M,c);<br>}<br>else if(c!=T)<br>{<br>move(‘B’,’C’);<br>t=(b+c&lt;T)?b:T-c;<br>divide(a,b-t,c+t);<br>}<br>else<br>{<br>move(‘C’,’A’);<br>divide(a+T,b,0);<br>}<br>}<br>}<br>void main()<br>{<br>divide(L,0,0);<br>if(n%5!=0)<br>{<br>putchar(‘\n’);<br>}<br>}<br>（2）快速排序<br>快速排序，说白了就是给基准数据找其正确索引位置的过程。<br>如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.</p>
<p>首先从后半部分开始，如果扫描到的值大于基准数据就让high减1,如果发现有元素比该基准数据的值小(如上图中18&lt;=tmp)，就将high位置的值赋值给low位置 ,结果如下:</p>
<p>然后开始从前往后扫描,如果扫描到的值小于基准数据就让low加1,如果发现有元素大于基准数据的值(如上图46=&gt;tmp)，就再将low位置的值赋值给high位置的值,指针移动并且数据交换后的结果如下:</p>
<p>然后再开始从后向前扫描,原理同上,发现上图11&lt;=tmp,则将low位置的值赋值给high位置的值,结果如下:</p>
<p>然后再开始从前往后遍历,直到low=high结束循环,此时low或high的下标就是基准数据23在该数组中的正确索引位置.如下图所示.</p>
<p>这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的右边,把比基准数小的放在基准数的左边,这样就找到了该数据在数组中的正确位置.以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。<br>从上面的过程中可以看到：<br>①先从队尾开始向前扫描且当low &lt; high时,如果a[high] &gt; tmp,则high–,但如果a[high] &lt; tmp,则将high的值赋值给low,即arr[low] = a[high],同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了<br>②同理,当从队首开始向队尾进行扫描时,如果a[low] &lt; tmp,则low++,但如果a[low] &gt; tmp了,则就需要将low位置的值赋值给high位置,即arr[low] = arr[high],同时将数组扫描方式换为由队尾向队首进行扫描.<br>③不断重复①和②,知道low&gt;=high时(其实是low=high),low或high的位置就是该基准数据在数组中的正确索引位置.<br>代码实现：<br>问题1（2018-5-3）<br>下面的程序快速排序的核心代码，请仔细阅读并补充完整。<br>void QuickSort(int array[],int *startIndex,int *endIndex)<br>{<br>if(startIndex&gt;=endIndex)<br>{<br>return;<br>}<br>int *bond=bowndary(arry,startIndex,endIndex);<br>QuickSort(array,startIndex,【2】);<br>QuickSort(array,【3】,endIndex);<br>}<br>int *boundary(int array[],int *startIndex,int *endIndex)<br>{<br>int standard=*startIndex;<br>int *leftIndex=startIndex;<br>int *rightIndex=endIndex;<br>while(leftIndex&lt;rightIndex)<br>{<br>while(leftIndex&lt;rightIndex&amp;&amp;*rightIndex&gt;=standard)<br>{<br>rightIndex–;<br>}<br>【4】______________________;<br>while(leftIndex&lt;rightIndex&amp;&amp;*leftIndex&lt;=standard)<br>{<br>leftIndex++;<br>}<br>【5】_____________________;<br>}<br>【6】_____________________;<br>return leftIndex;<br>}<br>}</p>
<h2 id="11-递推与递归"><a href="#11-递推与递归" class="headerlink" title="11.递推与递归"></a>11.递推与递归</h2><p>这个面积就太大了，属实在“画饼”，历年真题基本必出现递归问题，如2020的八皇后及约瑟夫环的问题，因此把历年真题出现过的递归递推弄明白就可以了，真要是碰到没见过的基本大家起跑线一样。</p>
<h2 id="12-动态规划"><a href="#12-动态规划" class="headerlink" title="12.动态规划"></a>12.动态规划</h2><p>动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。因此在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。我们也可以通过对若干有代表性的问题的动态规划算法进行分析、讨论，逐渐学会并掌握这一设计方法。<br>动态规划解决的是哪类问题？<br>与分治法不同，适用于动态规划求解的问题经分解得到的子问题往往不是相互独立的。<br>什么情况下能用动态规划？<br>使用动态规划需要满足以下性质 1.最优子结构 2.重叠子问题<br>1.最优子结构：当问题的最优解包含了子问题的最优解时，称该问题具有最优子结构。<br>2.重叠子问题：在递归求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。<br>为什么要用动态规划<br>动态规划能提高解决上述这类问题的效率。<br>动态规划利用子问题的重叠性质，对每一个子问题只解一次，而后将其保存在一个表格中，当再次需要解决此子问题是，只需要简单的常数时间查看结果。<br>2.设计动态规划算法的步骤<br>（1）找出最优解的性质，并刻画其结构特征。<br>（2）递归的定义最优值。<br>（3）以自低向上的方式计算出最优值。<br>（4）根据计算最优值得到的信息，构造最优解。<br>问题1.求最长公共子序列<br>有两个字符串S1和S2，求一个最长公共子串，即求字符串S3,它同时为S1和S2的子串，且要求它的长度最长，并确定这个长度。这个问题被我们称为最长公共子序列问题。<br>实际应用[算法图解P150]假设你管理一个网站，用户在该网站输入单词时，你需要给出其定义。（或查询某单词含义，如有道翻译）。但如果用户拼错了，你必须猜测他原本要输入的是什么单词。例如，某人本来想查单词fish，但是却输入了hish，在你的字典里根本没有hish这样的单词，但有几个类似的单词，你要筛选出和fish最接近的单词。<br>思路：<br>事实上，最长公共子序列问题具有最优子结构性质。<br>设序列X={x1，x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={<br>z1,z2,…zk},则<br>（1）若xm=yn,则zk=xm=yn,且Zk-1是Xm-1和Ym-1的最长公共子序列。<br>（2）若xm!=yn,且zk！=xm，则Zk-1是Xm-1和Y的最长公共子序列。<br>（3）若xm!=yn,且zk！=yn，则Zk-1是Yn-1和Y的最长公共子序列。<br>令c[i][j]表示序列Xi和Yj的最长公共子序列的长度。<br>则由最优子结构性质可以建立递归关系如下：<br>1)c[i][j]=0;//当i=0,j=0<br>2)c[i][j]=c[i-1][j-1]+1//当i,j&gt;0;xi=yj<br>3)c[i][j]=max{c[i][j-1],c[i-1][j]}//i,j&gt;0;xi!=yj</p>
<p>代码实现<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#define M 100<br>#define N 100<br>int c[M][N];// 用于保存Xi和Yi的最长公共子序列的长度<br>char lcstr[10000];<br>int lcsLength(char strx[],char stry[],int b[][N])//b[i][j]用于保存c[i][j]由哪一个子问题得到的<br>{</p>
<pre><code>int m,n,i,j;m=strlen(strx);n=strlen(stry);for(i=0;i&lt;=m;i++)&#123;    c[i][0]=0;&#125;for(i=1;i&lt;=n;i++)&#123;    c[0][i]=0;&#125;for(i=1;i&lt;=m;i++)//用迭代&#123;    for(j=1;j&lt;=n;j++)    &#123;        if(strx[i-1]==stry[j-1])        &#123;            c[i][j]=c[i-1][j-1]+1;            b[i][j]=1;        &#125;else if(c[i-1][j]&gt;=c[i][j-1])        &#123;            c[i][j]=c[i-1][j];            b[i][j]=2;        &#125;else&#123;            c[i][j]=c[i][j-1];            b[i][j]=3;        &#125;    &#125;&#125;return c[m][n];
</code></pre>
<p>}<br>//构造最长公共子序列,此函数打印最大公共子序列<br>void lcs(int i,int j,char strx[],int b[][N])<br>{<br>    if(i==0||j==0)<br>    {<br>        if(b[0][0]==1)<br>        {<br>            printf(“%c”,strx[0]);<br>        }</p>
<pre><code>    return ;&#125;if(b[i][j]==1)&#123;    lcs(i-1,j-1,strx,b);    printf(&quot;%c&quot;,strx[i-1]);&#125;else if(b[i][j]==2)&#123;    lcs(i-1,j,strx,b);&#125;else&#123;    lcs(i,j-1,strx,b);&#125;
</code></pre>
<p>}<br>int main()<br>{<br>    char x[]=”abc”;<br>    char y[]=”bc”;<br>    int record[M][N];<br>    int result=lcsLength(x,y,record);<br>    printf(“%d\n”,result);<br>    int strlenx=strlen(x);<br>    int strleny=strlen(y);<br>    int i,j;<br>    for(i=0;i&lt;strlenx;i++)<br>    {<br>        for(j=0;j&lt;strleny;j++)<br>        {<br>            printf(“%d “,record[i][j]);<br>        }<br>        printf(“\n”);</p>
<pre><code>&#125;lcs(strlenx,strleny,x,record);return 0;
</code></pre>
<p>}</p>
<p>问题2 求一个字符串中的最长的回文子串<br>回文是指正着读和倒着读，结果一样，比如abcba或abba。<br>分析：<br>令状态方程p[i][j]=0表示起始位置为i,结束位置为j的字符串不为回文，<br>p[i][j]=1,表示此回文。<br>状态转移方程为<br>p[i][j]=<br>{<br>p[i][j]=1;//若p[i+1][j-1]==1且str[i]==str[j];<br>p[i][j]=0//其他<br>}<br>代码实现<br>#include <iostream><br>#include <string><br>using namespace std;<br>string longestPalindrome(string &amp;str)<br>{<br>    int length=str.size();<br>    int start,maxlen;//最大子字符串的起点位置和长度<br>    int len;//长度的临时变量<br>    int p[100][100]={false};//构建一个length*length的p矩阵来表示回文<br>    for(int i=0;i&lt;length;i++)<br>    {<br>        p[i][i]=1;//构建i行j列的二维矩阵，显然对角线仅含一个字符，默认为1，即单独字符为回文字符<br>        if(p[i][i]&amp;&amp;str[i]==str[i+1])<br>        {<br>            p[i][i+1]=true;//当连续两个字符相同时，即回文为2<br>            maxlen=2;<br>            start=i;<br>        }<br>    }<br>    //len从1开始还是从0开始？<br>    //从0开始,否则当i=0，len=str.size()，i+len会越界，所以len的取值区间[0,length-1]<br>    for(len=2;len&lt;length;len++)<br>    {<br>        for(int i=0;i&lt;length-1-len;i++)//当长度为len+1，起点i的位置最大位置length-（len+1）-1，即子串的长度为<br>        {<br>            int j=i+len;<br>            if(p[i+1][j-1]&amp;&amp;str[i]==str[j])<br>            {<br>                p[i][i+len]=1;<br>                maxlen=len+1;<br>                start=i;</string></iostream></p>
<pre><code>        &#125;else&#123;            p[i][i+len]==0;        &#125;    &#125;&#125;if(maxlen&gt;2)&#123;        return str.substr(start,maxlen);&#125;return NULL;
</code></pre>
<p>}<br>int main()<br>{<br>    string str=”auuabab”;<br>    cout&lt;&lt;longestPalindrome(str);//如果用c语言实现换成printf就行<br>    return 0;<br>}</p>
<p>问题3：最短路径问题。下图给出了一个地图，地图中的每个顶点代表一个城市，两个城市间的一条连线代表道路，连线上的数值代表道路的长度。现在想从城市A到达城市E，怎样走路程最短？最短路程的长度是多少？</p>
<p>【算法分析】<br>        把A到E的全过程分成四个阶段，用K表示阶段变量，第1阶段有一个初始状态A，有两条可供选择的支路A-B1、A-B2；第2阶段有两个初始状态B1、B2，B1有三条可供选择的支路，B2有两条可供选择的支路……。用DK（XI，X+1J）表示在第K阶段由初始状态XI到下阶段的初始状态X+1J的路径距离，FK（XI）表示从第K阶段的XI到终点E的最短距离，利用倒推的方法，求解A到E的最短距离。<br>具体计算过程如下：<br>S1： K = 4 有<br>         F4（D1）= 3，<br>         F4（D2）= 4，<br>         F4（D3）= 3；<br>S2： K = 3 有<br>         F3（C1）= MIN{ D3（C1，D1）+ F4（D1），D3（C1，D2）+ F4（D2）}<br>                         = MIN{ 5+3，6+4 } = 8<br>         F3（C2）= D3（C2，D1）+ F4（D1）= 5+3 = 8<br>         F3（C3）= D3（C3，D3）+ F4（D3）= 8+3 = 11<br>         F3（C4）= D3（C4，D3）+ F4（D3）= 3+3 = 6<br>S3： K = 2 有<br>         F2（B1）= MIN{ D2（B1，C1）+ F3（C1），D2（B1，C2）+ F3（C2），<br>         D2（B1，C3）+ F3(C3)} = MIN{ 1+8,6+8,3+11} = 9<br>         F2（B2）= MIN{ D2（B2，C2）+ F3（C2），D2（B2，C4）+ F3（C4）}<br>                         = MIN{ 8+8，4+6 } = 10<br>S4： K = 1 有<br>         F1（A）= MIN{ D1（A，B1）+ F2（B1），D1（A，B2）+ F2（B2）}<br>                       = MIN{ 5+9，3+10} = 13<br>因此由A点到E点的全过程最短路径为A→B2→C4→D3→E；最短路程长度为13。<br>从以上过程可以看出，每个阶段中，都求出本阶段的各个初始状态到终点E的最短距离，当逆序倒推到过程起点A时，便得到了全过程的最短路径和最短距离。<br>在上例的多阶段决策问题中，各个阶段采取的决策，一般来说是与阶段有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，我们称这种解决多阶段决策最优化的过程为动态规划程序设计方法。<br>#include<iostream><br>#include<cstring><br>using namespace std;<br>int main()<br>{<br>   long d[5][5][5],f[10][10];// d[i][j][k]表示第i个阶段第j个数到下一阶段第k个数的路径长度。f[i][j]表示第i个阶段第j个数的最短路径<br>   memset(d,42,sizeof(d));          //有些路径是不通的,赋值为较大值，用于判断<br>   d[1][1][1]=5;d[1][1][2]=3;d[2][1][1]=1;  //以下给可通路径赋正常值<br>   d[2][1][2]=6;d[2][1][3]=3;d[2][2][2]=8<br>   d[2][2][4]=4;d[3][1][1]=5;d[3][1][2]=6;<br>   d[3][2][1]=5;d[3][3][3]=8;d[3][4][3]=3;<br>   d[4][1][1]=3;d[4][2][1]=4;d[4][3][1]=3;<br>   for (int i=0;i&lt;=9;++i)<br>    for (int j=0;j&lt;=9;++j) f[i][j]=10000000;<br>   f[5][1]=0;<br>   for (int i=4;i&gt;=1;–i)<br>    for (int j=1;j&lt;=4;++j)<br>     for (int k=1;k&lt;=4;++k)<br>       if (f[i][j]&gt;d[i][j][k]+f[i+1][k])    //即使走非法路径，也不影响答案<br>          f[i][j]=d[i][j][k]+f[i+1][k];<br>    cout&lt;&lt;f[1][1]&lt;&lt;endl;<br>}</cstring></iostream></p>
<p>问题4 数塔问题（IOI94）有形如图所示的数塔，从顶部出发，在每一结点可以选择向左走或是向右走，一起走到底层，要求找出一条路径，使路径上的值最大。</p>
<p>【算法分析】这道题如果用枚举法，在数塔层数稍大的情况下（如40），则需要列举出的路径条数将是一个非常庞大的数目。如果用贪心法又往往得不到最优解。在用动态规划考虑数塔问题时可以自顶向下的分析，自底向上的计算。从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值，只要左右两道路径上的最大值求出来了才能作出决策。同样的道理下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。这样一层一层推下去，直到倒数第二层时就非常明了。所以实际求解时，可从底层开始，层层递进，最后得到最大值。<br>一般说来，很多最优化问题都有着对应的计数问题；反过来，很多计数问题也有着对应的最优化问题。因此，我们在遇到这两类问题时，不妨多联系、多发展，举一反三，从比较中更深入地理解动态规划的思想。<br>其实递推和动态规划这两种方法的思想本来就很相似，也不必说是谁借用了谁的思想。关键在于我们要掌握这种思想，这样我们无论在用动态规划法解最优化问题，或是在用递推法解判定型、计数问题时，都能得心应手、游刃有余了。<br>①贪心法往往得不到最优解：本题若采用贪心法则：13-11-12-14-13，其和为63,但存在另一条路：13-8-26-15-24，其和为86。贪心法问题所在：眼光短浅。<br>②动态规划求解：动态规划求解问题的过程归纳为：自顶向下的分析，自底向上计算。<br>其基本方法是：划分阶段：按三角形的行，划分阶段，若有n行，则有n-1个阶段。<br>A．从根结点13出发，选取它的两个方向中的一条支路，当到倒数第二层时，每个结点其后继仅有两个结点，可以直接比较，选择最大值为前进方向，从而求得从根结点开始到底端的最大路径。<br>B．自底向上计算：（给出递推式和终止条件）<br>   ①从底层开始，本身数即为最大数；<br>   ②倒数第二层的计算，取决于底层的数据：12+6=18，13+14=27，24+15=39，24+8=32；<br>   ③倒数第三层的计算，取决于底二层计算的数据：27+12=39，39+7=46，39+26=65<br>   ④倒数第四层的计算，取决于底三层计算的数据：46+11=57，65+8=73<br>   ⑤最后的路径：13——8——26——15——24<br>C．数据结构及算法设计<br>   ①图形转化：直角三角形，便于搜索：向下、向右<br>   ②用三维数组表示数塔：a[x,y,1]表示行、列及结点本身数据,a[x,y,2]能够取得最大值,a[x,y,3]表示前进的方向——0向下，1向右；<br>   ③算法：<br>数组初始化，输入每个结点值及初始的最大路径、前进方向为0；<br>从倒数第二层开始向上一层求最大路径，共循环N-1次；<br>从顶向下，输出路径：究竟向下还是向右取决于列的值，若列的值比原先多1则向右，否则向下。<br>【代码实现】<br>#include<iostream><br>#include<cstring><br>using namespace std;<br>int main()<br>{<br>    int n,x,y;<br>    int a[51][51][3];<br>    cout&lt;&lt;”please input the number of rows:”;<br>    cin&gt;&gt;n;<br>    memset(a,0,sizeof(0));<br>    for (x=1;x&lt;=n;x++)                         //输入数塔的初始值<br>         for (y=1;y&lt;=x;y++)<br>             {<br>            cin&gt;&gt;a[x][y][1];//节点数据<br>            a[x][y][2]=a[x][y][1];//当前最大值，即仅有一个点的时候自身就是最大值<br>            a[x][y][3]=0;                          //路径走向，默认向下<br>        }<br>    for (x=n-1;x&gt;=1;x–)//注意是从底部倒数第二层开始找<br>       for (y=1;y&lt;=x;y++)<br>           if (a[x+1][y][2]&gt;a[x+1][y+1][2])        //选择路径，保留最大路径值，如从点13开始有11和8两条路径，比较这两条路径哪个值最大<br>{a[x][y][2]=a[x][y][2]+a[x+1][y][2];a[x][y][3]=0;}//如选择11这条路径，则向下走<br>       else {a[x][y][2]=a[x][y][2]+a[x+1][y+1][2];a[x][y][3]=1;} //否则选择8这条路径，8在数组中位于13的右侧，即向右走<br>      cout&lt;&lt;”max=”&lt;&lt;a[1][1][2]&lt;&lt;endl;     //输出数塔最大值<br>      y=1;<br>      for (x=1;x&lt;=n-1;x++)                 //输出数塔最大值的路径<br>      {<br>             cout&lt;&lt;a[x][y][1]&lt;&lt;”-&gt;”;<br>             y=y+a[x][y][3];                       //下一行的列数<br>      }<br>     cout&lt;&lt;a[n][y][1]&lt;&lt;endl;<br>}</cstring></iostream></p>
<h2 id="13-搜索"><a href="#13-搜索" class="headerlink" title="13.搜索"></a>13.搜索</h2><p>这一部分很难，从2020真题观察不会出到这种难度的填空或者看程序写结果，顶多在写代码中出现，如果感觉太难的可以战略放弃。</p>
<h3 id="（1）广度优先搜索"><a href="#（1）广度优先搜索" class="headerlink" title="（1）广度优先搜索"></a>（1）广度优先搜索</h3><p>有需要可以刷一下leecode上的题库：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/breadth-first-search/">https://leetcode-cn.com/tag/breadth-first-search/</a><br>主要思想：层层递进<br>首先以一个未被访问过的顶点作为起始顶点,访问其所有相邻的顶点,然后对每个相邻的顶点,再访问它们相邻的未被访问过的顶点，直到所有顶,点都被访问过,遍历结束。<br>一般可以用它做什么呢？一个最直观经典的例子就是走迷宫，我们从起点开始，找出到终点的最短路程，很多最短路径算法就是基于广度优先的思想成立的。<br>刚刚说的广度优先搜索是连通图的一种遍历策略，那就有必要将图先简单解释一下。</p>
<p>如图所示，这就是我们所说的连通图，这里展示的是一个无向图，连通即每2个点都有至少一条路径相连，例如V0到V4的路径就是V0-&gt;V1-&gt;V4。<br>一般我们把顶点用V缩写，把边用E缩写。<br>算法的基本思路<br>常常我们有这样一个问题，从一个起点开始要到一个终点，我们要找寻一条最短的路径，从图2-1举例，如果我们要求V0到V6的一条最短路（假设走一个节点按一步来算）【注意：此处你可以选择不看这段文字直接看图3-1】，我们明显看出这条路径就是V0-&gt;V2-&gt;V6，而不是V0-&gt;V3-&gt;V5-&gt;V6。先想想你自己刚刚是怎么找到这条路径的：首先看跟V0直接连接的节点V1、V2、V3，发现没有V6，进而再看刚刚V1、V2、V3的直接连接节点分别是：{V0、V4}、{V0、V1、V6}、{V0、V1、V5}（这里画删除线的意思是那些顶点在我们刚刚的搜索过程中已经找过了，我们不需要重新回头再看他们了）。这时候我们从V2的连通节点集中找到了V6，那说明我们找到了这条V0到V6的最短路径：V0-&gt;V2-&gt;V6，虽然你再进一步搜索V5的连接节点集合后会找到另一条路径V0-&gt;V3-&gt;V5-&gt;V6，但显然他不是最短路径。<br>你会看到这里有点像辐射形状的搜索方式，从一个节点，向其旁边节点传递病毒，就这样一层一层的传递辐射下去，知道目标节点被辐射中了，此时就已经找到了从起点到终点的路径。<br>我们采用示例图来说明这个过程，在搜索的过程中，初始所有节点是白色（代表了所有点都还没开始搜索），把起点V0标志成灰色（表示即将辐射V0），下一步搜索的时候，我们把所有的灰色节点访问一次，然后将其变成黑色（表示已经被辐射过了），进而再将他们所能到达的节点标志成灰色（因为那些节点是下一步搜索的目标点了），但是这里有个判断，就像刚刚的例子，当访问到V1节点的时候，它的下一个节点应该是V0和V4，但是V0已经在前面被染成黑色了，所以不会将它染灰色。这样持续下去，直到目标节点V6被染灰色，说明了下一步就到终点了，没必要再搜索（染色）其他节点了，此时可以结束搜索了，整个搜索就结束了。然后根据搜索过程，反过来把最短路径找出来，图3-1中把最终路径上的节点标志成绿色。<br>整个过程的实例图如下图所示。</p>
<p>初始全部都是白色（未访问）</p>
<p>即将搜索起点V0（灰色）</p>
<p>已搜索V0，即将搜索V1、V2、V3</p>
<p>……终点V6被染灰色，终止</p>
<p>找到最短路径<br>广度优先搜索流程图</p>
<p>迷宫问题<br>定义一个二维数组：<br>int maze[5][5] = {<br>    0, 1, 0, 0, 0,<br>    0, 1, 0, 1, 0,<br>    0, 0, 0, 0, 0,<br>    0, 1, 1, 1, 0,<br>    0, 0, 0, 1, 0,<br>};<br>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。<br>分析：<br>对应于《迷宫问题》，你可以这么认为，节点就是迷宫路上的每一个格子（非墙），走迷宫的时候，格子间的关系是什么呢？按照题目意思，我们只能横竖走，因此我们可以这样看，格子与它横竖方向上的格子是有连通关系的，只要这个格子跟另一个格子是连通的，那么两个格子节点间就有一条边。<br>如果说本题再修改成斜方向也可以走的话，那么就是格子跟周围8个格子都可以连通，于是一个节点就会有8条边（除了边界的节点）。<br>对应于题目的输入数组：<br>0, 1, 0, 0, 0,<br>    0, 1, 0, 1, 0,<br>    0, 0, 0, 0, 0,<br>    0, 1, 1, 1, 0,<br>    0, 0, 0, 1, 0,<br>我们把节点定义为(x,y)，(x,y)表示数组maze的项maze[x][y]。<br>于是起点就是(0,0)，终点是(4,4)。按照刚刚的思路，我们大概手工梳理一遍：<br>初始条件：<br>起点Vs为(0,0)<br>终点Vd为(4,4)<br>灰色节点集合Q={}<br>初始化所有节点为白色节点<br>开始我们的广度搜索！<br>手工执行步骤【PS：你可以直接看图4-1】:<br>1.起始节点Vs变成灰色，加入队列Q，Q={(0,0)}<br>2.取出队列Q的头一个节点Vn，Vn={0,0}，Q={}<br>3.把Vn={0,0}染成黑色，取出Vn所有相邻的白色节点{(1,0)}<br>4.不包含终点(4,4)，染成灰色，加入队列Q，Q={(1,0)}<br>5.取出队列Q的头一个节点Vn，Vn={1,0}，Q={}<br>6.把Vn={1,0}染成黑色，取出Vn所有相邻的白色节点{(2,0)}<br>7.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,0)}<br>8.取出队列Q的头一个节点Vn，Vn={2,0}，Q={}<br>9.把Vn={2,0}染成黑色，取出Vn所有相邻的白色节点{(2,1), (3,0)}<br>10.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,1), (3,0)}<br>11.取出队列Q的头一个节点Vn，Vn={2,1}，Q={(3,0)}</p>
<ol start="12">
<li>把Vn={2,1}染成黑色，取出Vn所有相邻的白色节点{(2,2)}<br>13.不包含终点(4,4)，染成灰色，加入队列Q，Q={(3,0), (2,2)}<br>14.持续下去，知道Vn的所有相邻的白色节点中包含了(4,4)……<br>15.此时获得了答案<br>我们来看看广度搜索的过程中节点的顺序情况：</li>
</ol>
<p>你是否观察到了，广度搜索的顺序是什么样子的？<br>图中标号即为我们搜索过程中的顺序，我们观察到，这个搜索顺序是按照上图的层次关系来的，例如节点(0,0)在第1层，节点(1,0)在第2层，节点(2,0)在第3层，节点(2,1)和节点(3,0)在第3层。<br>我们的搜索顺序就是第一层-&gt;第二层-&gt;第三层-&gt;第N层这样子。<br>我们假设终点在第N层，因此我们搜索到的路径长度肯定是N，而且这个N一定是所求最短的。<br>我们用简单的反证法来证明：假设终点在第N层上边出现过，例如第M层，M&lt;N，那么我们在搜索的过程中，肯定是先搜索到第M层的，此时搜索到第M层的时候发现终点出现过了，那么最短路径应该是M，而不是N了。<br>所以根据广度优先搜索的话，搜索到终点时，该路径一定是最短的。<br>代码实现：<br>/** </p>
<ul>
<li>广度优先搜索 </li>
<li>@param Vs 起点 </li>
<li>@param Vd 终点<br>*/<br>bool BFS(Node&amp; Vs, Node&amp; Vd){<br>  queue<Node> Q;<br>  Node Vn, Vw;<br>  int i;<br>//用于标记颜色当visit[i][j]==true时，说明节点访问过，也就是黑色<br>bool visit[MAXL][MAXL];<br>//四个方向<br>int dir[][2] = {  <pre><code>&#123;0, 1&#125;, &#123;1, 0&#125;,  
&#123;0, -1&#125;, &#123;-1, 0&#125;  
</code></pre>
};<br>//初始状态将起点放进队列Q<br>Q.push(Vs);<br>visit[Vs.x][Vs.y] = true;//设置节点已经访问过了！<br>while (!Q.empty()){//队列不为空，继续搜索！  <pre><code>//取出队列的头Vn  
Vn = Q.front();  
Q.pop();  
for(i = 0; i &lt; 4; ++i)&#123;  
    Vw = Node(Vn.x+dir[i][0], Vn.y+dir[i][1]);//计算相邻节点  
    if (Vw == Vd)&#123;//找到终点了！  
        //把路径记录，这里没给出解法  
        return true;//返回  
    &#125;  
    if (isValid(Vw) &amp;&amp; !visit[Vw.x][Vw.y])&#123;  
        //Vw是一个合法的节点并且为白色节点  
        Q.push(Vw);//加入队列Q  
        visit[Vw.x][Vw.y] = true;//设置节点颜色  
    &#125;  
  &#125;  
</code></pre>
}<br>  return false;//无解<br>}</Node></li>
</ul>
<h3 id="（2）深度优先搜索"><a href="#（2）深度优先搜索" class="headerlink" title="（2）深度优先搜索"></a>（2）深度优先搜索</h3><p>主要思想：不撞南墙不回头<br>深度优先遍历的主要思想就是：首先以一个未被访问过的顶点作为起始顶点，沿着当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则返回上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问过。<br>通过上面的图例可以非常直观的了解深度优先搜索的工作方式。下面来分析一下如何用代码来实现它。<br>大家都知道，深度优先的主要思想就是“不撞南墙不回头”，“一条路走到黑”，如果遇到“墙”或者“无路可走”时再去走下一条路。所以先规定好一个走路的规则，比如就按照右下左上顺时针的方式去尝试。如位置是起始点，先往右走，但是有堵墙走不了，所以按照规定尝试往下走。到达“1”的位置，此时重复刚才的步骤，先向右走可以走到“2”，再重复规则发现向右可以走到“3”，再重复发现“下右左上”四个方向都不能走，这时候就退回“2”的位置尝试向下走。。。依次类推直到走到最终的目的地。聪明的你肯定已经发现了“递归”是实现深度优先搜索的最好的方式。定义好规则然后就这样递归的循环下去直到走到终点<br>    // 深度优先搜索<br>    public void DFS( int x, int y )<br>        throws Exception<br>    {<br>        int tx, ty;<br>        int[] pos =<br>            { x, y };<br>        dfs_posList.add(pos);<br>        // 是否到达目的地<br>        if (mMapView[y][x] == 8)<br>        {<br>            throw new Exception(“find”);<br>        }<br>        // 顺时针循环，右下左上四个方向<br>        for (int k = 0; k &lt; 4; k++)<br>        {<br>            tx = x + next[k][1];<br>            ty = y + next[k][0];<br>            // 是否出了边界<br>            boolean isOut = tx &lt; 0 || tx &gt;= mapWidth || ty &lt; 0 || ty &gt;= mapHeight;<br>            if (!isOut)<br>            {<br>                // 是否是障碍物<br>                if (mMapView[ty][tx] == 0 &amp;&amp; dfs_book[tx][ty] == 0 || mMapView[ty][tx] == 8)<br>                {<br>                    dfs_book[tx][ty] = 1;<br>                    DFS(tx, ty);<br>                    dfs_book[tx][ty] = 0;<br>                }<br>            }<br>        }<br>    }<br>// 判断方向的数组<br>int[][] next =<br>        {<br>                { 0, 1 }, // 右<br>                { 1, 0 }, // 下<br>                { 0, -1 }, // 左<br>                { -1, 0 } // 上<br>        };</p>
<h2 id="14-图论算法"><a href="#14-图论算法" class="headerlink" title="14.图论算法"></a>14.图论算法</h2><h3 id="1-Dijkstra算法"><a href="#1-Dijkstra算法" class="headerlink" title="1.Dijkstra算法"></a>1.Dijkstra算法</h3><p>狄克斯特拉(Dijkstra)算法算是贪心思想实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。<br>步骤：</p>
<ol>
<li>找出最便宜的节点，即可在最短时间内前往的节点。</li>
<li>对于该节点的邻居，检查是否有前往他们的最短路径，如果有，就更新其开销。</li>
<li>重复这个过程，直到对图中的每个节点都这样做了。</li>
<li>计算最终路径。</li>
</ol>
<p>问题引入：<br>指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。例如求下图中的1号顶点到2、3、4、5、6号顶点的最短路径。<br><img src="https://img-blog.csdnimg.cn/2021031219171071.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210312191721220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下面我们来模拟一下：<br><img src="https://img-blog.csdnimg.cn/20210312191741361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这就是Dijkstra算法的基本思路：<br>接下来是代码：<br>已经把几个过程都封装成了基本模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f <span class="comment">//路径的最大值using namespace std;int map[1005][1005];int vis[1005], dis[1005]; //vis用来标记已作为中间节点完成访问的顶点，dis用于存储从起点start到其他顶点的最短路径int n, m;                 //n个点，m条边void Init()&#123;    memset(map, Inf, sizeof(map)); //初始化map数组所有元素都是Inf    for (int i = 1; i &lt;= n; i++)    &#123;        map[i][i] = 0; //节点到其本身的距离为0    &#125;&#125;void Getmap()&#123;    int u, v, w;    for (int t = 1; t &lt;= m; t++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        if (map[u][v] &gt; w) //存储顶点和及其权重        &#123;            map[u][v] = w;            map[v][u] = w;        &#125;    &#125;&#125;void Dijkstra(int u)&#123;    memset(vis, 0, sizeof(vis)); //vis用来标记已作为中间节点完成访问的顶点，初始化为0    for (int t = 1; t &lt;= n; t++) //dis用于存储从起点start到其他顶点的最短路径，初始化为各个点到终点的距离    &#123;        dis[t] = map[u][t];    &#125;    vis[u] = 1; //将终点标记为已完成访问点    for (int t = 1; t &lt; n; t++)    &#123;        int minn = Inf, temp; //minn用于标记起点到其他未访问节点的最短路径        for (int i = 1; i &lt;= n; i++)        &#123;            if (!vis[i] &amp;&amp; dis[i] &lt; minn) //如果此点未完成访问并且得到的路径小于minn，则更新minn和temp            &#123;                minn = dis[i];                temp = i;            &#125;        &#125;        vis[temp] = 1;               //将此时与初始点最近的点标记为已访问节点        for (int i = 1; i &lt;= n; i++) //已此时标记的已访问节点为基准，更新此点到其他点的最短路径        &#123;            if (map[temp][i] + dis[temp] &lt; dis[i])            &#123;                dis[i] = map[temp][i] + dis[temp];            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);  //输入顶点数，边数    Init();                 //将节点到其自身的距离初始化为0    Getmap();               //输入顶点及两点之间的权重    Dijkstra(n);            //狄克斯特拉算法，将从第一个点到最后一个点的最短距离存储到dis数组中    printf(&quot;%d\n&quot;, dis[1]); //输出所要求的点到第一个点的最短距离    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-复杂实现算法："><a href="#2-复杂实现算法：" class="headerlink" title="2.复杂实现算法："></a>2.复杂实现算法：</h3><p>使用一个存放各顶点的当前距离的数组dist，一旦从源点v到顶点k的最短路径已经求出，则disk[k]就是从源点到顶点k的最短路径长度。使用数组pre，pre[j]存放从源点到顶点j的最短路径中j前面的顶点。我们可以方便地从pre数组中求得从源点v到其他顶点的路径。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>#<span class="meta-keyword">define</span> maxv 20typedef char VertexType;typedef struct MGraph&#123;    VertexType vexes[maxv]; <span class="comment">//顶点表    int edges[maxv][maxv];  //邻接矩阵,其元素值表示代价    int n, e;               //顶点数、边数&#125; mgraph;void Dijkstra(mgraph *g, VertexType v, int dist[maxv], int pre[maxv])&#123;    /*参数说明：g：邻接矩阵结构的图，v ：源点，dist ： 存放源点到各顶点距离，pre：存放路径*/    int vinx, i, j, k, min;    for (i = 0; i &lt; g-&gt;n; i++)    &#123;        if (v == g-&gt;vexes[i])        &#123;            vinx = i;            break;        &#125;    &#125;    for (i = 0; i &lt; g-&gt;n; i++)    &#123;        dist[i] = g-&gt;edges[vinx][i];        visited[i] = 0;        if (dist[i] &lt; maxweight)            pre[i] = vinx;        else            pre[i] = -1;    &#125;    visited[vinx] = 1;    pre[vinx] = 0;    for (i = 0; i &lt; g-&gt;n; i++)    &#123;        min = maxweight;        k = 0;        for (j = 0; j &lt; g-&gt;n; j++)        &#123;            if (visited[j] == 0)                if (dist[j] != 0 &amp;&amp; dist[j] &lt; min)                &#123;                    min = dist[j];                    k = j;                &#125;        &#125;        if (k == 0)            continue;        visited[k] = 1;        for (j = 0; j &lt; g-&gt;n; j++)        &#123;            if (visited[j] == 0 &amp;&amp; g-&gt;edges[k][j] &lt; maxweight)            &#123;                if (dist[k] + g-&gt;edges[k][j] &lt; dist[j])                &#123;                    dist[j] = dist[k] + g-&gt;edges[k][j];                    pre[j] = k;                &#125;            &#125;        &#125;    &#125;&#125;/*输出Dijkstra路径*/void print_dpath(mgraph *g, int path[maxv], int v, int u)&#123;    /*查找从v 到 u的路径*/    int k;    k = path[u];    if (k == -1)    &#123;        printf(&quot;no path!&quot;);        return;    &#125;    printf(&quot;%c&quot;, g-&gt;vexes[u]);    while (k != v)    &#123;        printf(&quot;&lt;--&quot;);        printf(&quot;%c&quot;, g-&gt;vexes[k]);        k = path[k];    &#125;    printf(&quot;&lt;--%c&quot;, g-&gt;vexes[k]);&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="15-字符串算法"><a href="#15-字符串算法" class="headerlink" title="15.字符串算法"></a>15.字符串算法</h2><p>同样和分治策略递归递推都是在“画饼”，历年真题出现过的关于字符串的都可以归到这一类问题上，因此还是没法了解其思想，把几个经典案例掌握下基本问题不大，如字符串匹配，字符数字统计，字符个数统计，字符数字转换整型数字等，例如2020出现的截取最长连续数字串代码，这种题型没法把握，随便网上扒拉个代码都是字符串，都是可以去考，因此在有限的时间和能力下把力所能及的代码分析明白就很不错了。</p>
<h3 id="（1）括号匹配算法"><a href="#（1）括号匹配算法" class="headerlink" title="（1）括号匹配算法"></a>（1）括号匹配算法</h3><p><strong>问题描述</strong>：在编写代码的时候，经常会用到两种括号：圆括号 “()” 和大括号 “{}” 。不管使用哪种括号，程序编译没有问题的其中一个重要因素就是所使用的括号是否能够匹配上。在编写程序时，括号可以嵌套，即： “({()})” 这种形式，但 “({)” 或者 “({}” 都不符合要求。括号匹配项目要求：给出任意搭配的括号，判断是否匹配。<br><strong>算法步骤：</strong> 编写程序判断括号匹配问题的时候，使用栈结构会很容易：<br>（1）如果碰到的是左圆括号或者左大括号，直接压栈；<br>（2）如果碰到的是右圆括号或者右大括号，就直接和栈顶元素配对：如果匹配，栈顶元素弹栈；反之，括号不匹配；<br><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>int top = -1;　　<span class="comment">//top变量时刻表示栈顶元素所在位置void push(char *a, int elem)&#123;    a[++top] = elem;&#125;void pop(char *a)&#123;    if (top == -1)         return ;        top--;&#125;char visit(char * a)&#123;    //调取栈顶元素，不等于弹栈，如果栈为空，为使程序不发生错误，返回空字符    if (top != -1) 　　 &#123;        return a[top];    &#125;　　 else　　 &#123;        return &#x27; &#x27;;    &#125;&#125;int main() &#123;    char a[30];    char bracket[100];    printf(&quot;请输入括号序列：&quot;);    scanf(&quot;%s&quot;, bracket);    getchar();    int length = (int)strlen(bracket);    for (int i=0; i&lt;length; i++) 　　 &#123;        //如果是左括号，直接压栈        if (bracket[i] == &#x27;(&#x27; || bracket[i] == &#x27;&#123;&#x27;) 　　　　 &#123;            push(a, bracket[i]);        &#125;else&#123;            //如果是右边括号，判断与栈顶元素是否匹配，如果匹配，栈顶元素弹栈，程序继续运行；否则，发现括号不匹配，输出结果直接退出            if (bracket[i] == &#x27;)&#x27;) 　　　　　　　&#123;                if (visit(a) == &#x27;(&#x27;) 　　　　　　　　　 &#123;                    pop(a);                &#125;　　　　　　　　　　else　　　　　　　　　　&#123;                    printf(&quot;括号不匹配&quot;);                    return 0;                &#125;            &#125;　　　　　　  else　　　　　　　&#123;                if (visit(a) == &#x27;&#123;&#x27;) 　　　　　　　　　 &#123;                    pop(a);                &#125;　　　　　　　　　 else　　　　　　　　　 &#123;                    printf(&quot;括号不匹配&quot;);                    return 0;                &#125;            &#125;        &#125;    &#125;    //如果所有括号匹配完成，栈内为空，说明所有括号全部匹配成功    if (top != -1) 　　 &#123;         printf(&quot;括号不匹配&quot;);    &#125;　　 else　　 &#123;         printf(&quot;括号匹配&quot;);    &#125;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>以下大纲提到的三种算法更魔性，个人认识不会考察到，比如近似算法是在贪心算法基础上到进一步优化代码，为啥不去考贪心呢？因为个人认为大体看一下算法什么意思以及提到的例题了解一下就可以。</p>
<h2 id="16-线段树"><a href="#16-线段树" class="headerlink" title="16.线段树"></a>16.线段树</h2><p>线段树也称为“区间树”，它的适用场景也是很普遍的，关注的重点是“线段”，或者说是区间。非常经典的线段树题目是“区间染色”，有的时候我们处理的数据的时候也需要进行区间的查询，比如说查询一个区间[i，j]的最大值，最小值，或者区间数字和。换成生活中的场景就是在2019年一年中，你的博客在什么时间段关注你的人增长最快啊，一天中自己的博文阅读量最高的时间段啊，某个星系中天体总量等等。这都可以是线段树的应用场景。<br>比较好的关于线段树的详解及例题：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AC-King/p/7789013.html">https://www.cnblogs.com/AC-King/p/7789013.html</a><br>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]。</p>
<blockquote>
<p><strong>问题1：</strong> 从数组arr[0…n-1]中查找某个数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新。</p>
</blockquote>
<p><strong>分析1：</strong> 对这个问题一个简单的解法是：遍历数组区间找到最小值，时间复杂度是O(n),额外的空间复杂度O(1)。当数据量特别大，而查询操作很频繁的时候，耗时可能会不满足需求。使用一个二维数组来保存提前计算好的区间[i,j]内的最小值，那么预处理时间为O(n^2)，查询耗时O(1),但是需要额外的O(n^2)空间，当数据量很大时，这个空间消耗是庞大的，而且当改变了数组中的某一个值时，更新二维数组中的最小值也很麻烦。<br>我们可以用线段树来解决这个问题：预处理耗时O(n)，查询、更新操作O(logn)，需要额外的空间O(n)。根据这个问题我们构造如下的二叉树<br>（1）叶子节点是原始组数arr中的元素<br>（2）非叶子节点代表它的所有子孙叶子节点所在区间的最小值<br><strong>例如</strong>对于数组[2, 5, 1, 4, 9,3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）：<br> <img src="https://img-blog.csdnimg.cn/20210314215626489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含n个叶子节点的完全二叉树，它一定有n-1个非叶节点，总共2n-1个节点，因此存储线段是需要的空间复杂度是O(n)。<br>对于线段树我们可以选择和普通二叉树一样的链式结构。由于线段树是完全二叉树，我们也可以用数组来存储，下面的讨论及代码都是数组来存储线段树，节点结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span>&#123;</span>　　<span class="keyword">int</span> val;&#125;；</span><br></pre></td></tr></table></figure>

<p>定义包含n个节点的线段树 SegTreeNodesegTree[n]，segTree[0]表示根节点。那么对于节点segTree[i]，它的左孩子是segTree[2<em>i+1],右孩子是segTree[2</em>i+2]。<br>我们可以从根节点开始，平分区间，递归的创建线段树，线段树的创建函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNUM = <span class="number">1000</span>;<span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span>&#123;</span>    <span class="keyword">int</span> val;&#125;segTree[MAXNUM];<span class="comment">//定义线段树/*功能：构建线段树root：当前线段树的根节点下标arr：用来构造线段树的数组istart：数组的起始位置iend：数组的结束位置*/void build(int root, int arr[], int istart, int iend)&#123;   if(istart == iend)//叶子节点        segTree[root].val = arr[istart];    else    &#123;        int mid = (istart + iend) / 2;        build(root*2+1, arr, istart, mid);//递归构造左子树       build(root*2+2, arr, mid+1, iend);//递归构造右子树        //根据左右子树根节点的值，更新当前根节点的值segTree[root].val=min(segTree[root*2+1].val,segTree[root*2+2].val);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>已经构建好了线段树，那么怎样在它上面超找某个区间的最小值呢？查询的思想是选出一些区间，使他们相连后恰好涵盖整个查询区间，因此线段树适合解决“相邻的区间的信息可以被合并成两个区间的并区间的信息”的问题。代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*功能：线段树的区间查询root：当前线段树的根节点下标[nstart，nend]：当前阶段所表示的区间[qstart，qend]：此次查询的区间*/</span><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> nstart, <span class="keyword">int</span> nend, <span class="keyword">int</span> qstart, <span class="keyword">int</span> qend)</span></span>&#123;    <span class="comment">//查询区间和当前节点区间没有交集：左区间qstart大于右区间nend或右区间qend小于左区间nstart    if(qstart &gt; nend || qend &lt;&lt;span style=&quot;font-family: &#x27;Courier New&#x27; !important;&quot;&gt; nstart)        return INFINITE;    //当前节点区间包含在查询区间内    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)        return segTree[root].val;    //分别从左右子树查询，返回两者查询结果的较小值    int mid = (nstart + nend) / 2;    return min(query(root*2+1, nstart, mid, qstart, qend),               query(root*2+2, mid + 1, nend, qstart, qend));&#125;</span></span><br></pre></td></tr></table></figure>

<p>举例说明（对照上面的二叉树）：<br>1、当我们要查询区间[0,2]的最小值时，从根节点开始，要分别查询左右子树，查询左子树时节点区间[0,2]包含在查询区间[0,2]内，返回当前节点的值1，查询右子树时，节点区间[3,5]和查询区间[0,2]没有交集，返回正无穷INFINITE，查询结果取两子树查询结果的较小值1，因此结果是1.<br>2、查询区间[0,3]时，从根节点开始，查询左子树的节点区间[0,2]包含在区间[0,3]内，返回当前节点的值1；查询右子树时，继续递归查询右子树的左右子树，查询到非叶节点4时，又要继续递归查询：叶子节点4的节点区间[3,3]包含在查询区间[0,3]内，返回4，叶子节点9的节点区间[4,4]和[0,3]没有交集，返回INFINITE,因此非叶节点4返回的是min(4,INFINITE) = 4，叶子节点3的节点区间[5,5]和[0,3]没有交集，返回INFINITE,因此非叶节点3返回min(4,INFINITE) = 4, 因此根节点返回 min(1,4) = 1。<br><strong>2.3单节点更新</strong><br>单节点更新是指只更新线段树的某个叶子节点的值，但是更新叶子节点会对其父节点的值产生影响，因此更新子节点后，要回溯更新其父节点的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOne</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> nstart, <span class="keyword">int</span> nend, <span class="keyword">int</span> index, <span class="keyword">int</span> addVal)</span></span>&#123;    <span class="keyword">if</span>(nstart == nend)    &#123;        <span class="keyword">if</span>(index == nstart)<span class="comment">//找到了相应的节点，更新之            segTree[root].val += addVal;        return;    &#125;    int mid = (nstart + nend) / 2;    if(index &lt;= mid)//在左子树中更新       updateOne(root*2+1, nstart, mid, index, addVal);    else updateOne(root*2+2, mid+1, nend, index, addVal);//在右子树中更新//根据左右子树的值回溯更新当前节点的值     segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如我们要更新叶子节点4（addVal =6）,更新后值变为10，那么其父节点的值从4变为9，非叶结点3的值更新后不变，根节点更新后也不变。<br><strong>2.4 区间更新</strong><br>区间更新是指更新某个区间内的叶子节点的值，因为涉及到的叶子节点不止一个，而叶子节点会影响其相应的非叶父节点，那么回溯需要更新的非叶子节点也会有很多，如果一次性更新完，操作的时间复杂度肯定不是O(lgn)，例如当我们要更新区间[0,3]内的叶子节点时，需要更新出了叶子节点3,9外的所有其他节点。为此引入了线段树中的延迟标记概念，这也是线段树的精华所在。<br>延迟标记：每个节点新增加一个标记，记录这个节点是否进行了某种修改(这种修改操作会影响其子节点)，对于任意区间的修改，我们先按照区间查询的方式将其划分成线段树中的节点，然后修改这些节点的信息，并给这些节点标记上代表这种修改操作的标记。在修改和查询的时候，如果我们到了一个节点p，并且决定考虑其子节点，那么我们就要看节点p是否被标记，如果有，就要按照标记修改其子节点的信息，并且给子节点都标上相同的标记，同时消掉节点p的标记。<br>因此需要在线段树结构中加入延迟标记域，本文例子中我们加入标记与addMark，表示节点的子孙节点在原来的值的基础上加上addMark的值，同时还需要修改创建函数build和 查询函数 query，修改的代码用红色字体表示，其中区间更新的函数为update，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFINITE = INT_MAX;<span class="keyword">const</span> <span class="keyword">int</span> MAXNUM = <span class="number">1000</span>;<span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span>&#123;</span>    <span class="keyword">int</span> val;    <span class="keyword">int</span> addMark;<span class="comment">//延迟标记&#125;segTree[MAXNUM];//定义线段树void build(int root, int arr[], int istart, int iend)&#123;    segTree[root].addMark = 0;//----设置标延迟记域    if(istart == iend)//叶子节点        segTree[root].val = arr[istart];     else    &#123;        int mid = (istart + iend) / 2;        build(root*2+1, arr, istart, mid);//递归构造左子树        build(root*2+2, arr, mid+1, iend);//递归构造右子树        //根据左右子树根节点的值，更新当前根节点的值        segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);    &#125;&#125;void pushDown(int root)&#123;   if(segTree[root].addMark != 0)    &#123;        //设置左右孩子节点的标志域，因为孩子节点可能被多次延迟标记又没有向下传递       //所以是 “+=”        segTree[root*2+1].addMark += segTree[root].addMark;        segTree[root*2+2].addMark += segTree[root].addMark;        //根据标志域设置孩子节点的值。因为我们是求区间最小值，因此当区间内每个元        //素加上一个值时，区间的最小值也加上这个值        segTree[root*2+1].val += segTree[root].addMark;       segTree[root*2+2].val += segTree[root].addMark;        //传递后，当前节点标记域清空        segTree[root].addMark = 0;    &#125;&#125;int query(int root, int nstart, int nend, int qstart, int qend)&#123;    //查询区间和当前节点区间没有交集    if(qstart &gt; nend || qend &lt;&lt;span style=&quot;font-family: &#x27;Courier New&#x27; !important;&quot;&gt; nstart)        return INFINITE;    //当前节点区间包含在查询区间内    if(qstart &lt;= nstart &amp;&amp; qend &gt;= nend)        return segTree[root].val;    //分别从左右子树查询，返回两者查询结果的较小值    pushDown(root); //----延迟标志域向下传递    int mid = (nstart + nend) / 2;    return min(query(root*2+1, nstart, mid, qstart, qend),               query(root*2+2, mid + 1, nend, qstart, qend));&#125;void update(int root, int nstart, int nend, int ustart, int uend, int addVal)&#123;   //更新区间和当前节点区间没有交集    if(ustart &gt; nend || uend &lt;&lt;span style=&quot;font-family: &#x27;Courier New&#x27; !important;&quot;&gt; nstart)        return ;    //当前节点区间包含在更新区间内    if(ustart &lt;= nstart &amp;&amp; uend &gt;= nend)    &#123;        segTree[root].addMark += addVal;        segTree[root].val += addVal;        return ;    &#125;    pushDown(root); //延迟标记向下传递    //更新左右孩子节点    int mid = (nstart + nend) / 2;    update(root*2+1, nstart, mid, ustart, uend, addVal);    update(root*2+2, mid+1, nend, ustart, uend, addVal);    //根据左右子树的值回溯更新当前节点的值     segTree[root].val = min(segTree[root*2+1].val, segTree[root*2+2].val);&#125;</span></span><br></pre></td></tr></table></figure>

<p>区间更新举例说明：当我们要对区间[0,2]的叶子节点增加2，利用区间查询的方法从根节点开始找到了非叶子节点[0-2]，把它的值设置为1+2=3，并且把它的延迟标记设置为2，更新完毕；当我们要查询区间[0,1]内的最小值时，查找到区间[0,2]时，发现它的标记不为0，并且还要向下搜索，因此要把标记向下传递，把节点[0-1]的值设置为2+2= 4，标记设置为2，节点[2-2]的值设置为1+2 =3，标记设置为2（其实叶子节点的标志是不起作用的，这里是为了操作的一致性），然后返回查询结果：[0-1]节点的值4；当我们再次更新区间[0,1]（增加3）时，查询到节点[0-1],发现它的标记值为2，因此把它的标记值设置为2+3= 5，节点的值设置为4+3 = 7；<br>其实当区间更新的区间左右值相等时（[i,i]），就相当于单节点更新，单节点更新只是区间更新的特例。<br><strong>蒙特卡罗方法：</strong><br>蒙特卡罗方法又叫统计模拟方法，它使用随机数（或伪随机数）来解决计算的问题，是一类重要的数值计算方法。该方法的名字来源于世界著名的赌城蒙特卡罗，而蒙特卡罗方法正是以概率为基础的方法。<br>一个简单的例子可以解释蒙特卡罗方法，假设我们需要计算一个不规则图形的面积，那么图形的不规则程度和分析性计算（比如积分）的复杂程度是成正比的。而采用蒙特卡罗方法是怎么计算的呢？首先你把图形放到一个已知面积的方框内，然后假想你有一些豆子，把豆子均匀地朝这个方框内撒，散好后数这个图形之中有多少颗豆子，<strong>再根据图形内外豆子的比例来计算面积</strong>。当你的豆子越小，撒的越多的时候，结果就越精确。<br> <img src="https://img-blog.csdnimg.cn/20210314215847316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhYmllbjAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如图所示的正方形其面积A=1；还有1/4的圆，其面积是π/4，这里如何利用几何图形的概率特性，即即蒙特卡洛算法，来近似计算圆周率 π的值呢。<br>想象这是一张纸，其中的圆弧线，将纸划分为两部分，在下雨时将这张纸放置室外，经过一段时间，雨点落在 14圆的个数为 C，落在整张纸上的雨点个数为D。则有C/D=A/B=π/4/1=π/4，可得 π=4C/D<br>可通过对大量重复随机实验来仿真或者近似计算CD的真实值。让计算机产生随机数x,y,x≤1,y≤1, 模拟雨点的分布情况。这里的关键问题是如何表示或者判断雨点落在扇形区域，即：√(x^2^+y^2^ )≤1，易写出如下的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span>int main(int, char**)&#123;    long c = 0, d = 0, N = 10000;    double x = 0, y = 0, pi = 0;    srand(unsigned(time(NULL)));    for (long i = 0; i &lt; N; ++i)    &#123;        d += 1;         x = double(rand()) / RAND_MAX;        y = double(rand()) / RAND_MAX;        <span class="meta-keyword">if</span> (sqrt(x*x + y*y) &lt;= 1)    <span class="comment">// x^2表示异或；            c += 1;    &#125;    printf(&quot;π= %f\n&quot;, 4.*c / d);    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iteration             π<br>100                2.9600<br>1000              3.116364<br>10000              3.150270<br>100000              3.138326<br>1000000           3.139696<br>10000000         3.141699<br>100000000          3.141511<br>1000000000         3.141521</p>
</blockquote>
<p>可见随着计算迭代次数的增加，估算的精度越来越高。</p>
<h2 id="17-随机算法"><a href="#17-随机算法" class="headerlink" title="17.随机算法"></a>17.随机算法</h2><h2 id="18-近似算法"><a href="#18-近似算法" class="headerlink" title="18.近似算法"></a>18.近似算法</h2><p>近似算法是一个大类。所有对于有确切最优解但是并不能保证得到最优解的算法都可以称之为近似算法。贪心算法不一定就是近似算法，如果可以证明决策既不受之前决策的影响，也不影响后续决策，则贪心算法就是确定的最优解算法。除此之外都不可以保证贪心算法是最优的。（这里有个很有意思的事情是，某种意义上动态规划方法就是将原问题变形为贪心可解的问题，因此对于每个状态只需要保留最优决策即可）<br>问题1：例如给定若干物品，要求尽可能的将衙门分成质量相近的两堆。如物品数为5，重量分别为3,3,2,2,2，很容易根据经验判断分成3+3和2+2+2的两堆。但这是一个2^n^级难题，数据量一大就出现组合爆炸。解决该问题目前还没有有效的方法。枚举法可以得到最优解，但时间复杂度为O（2^n^），难以接受。<br><strong>格雷厄姆（近似算法）</strong> 提出了解决该问题的近似算法。即每次从尚未分堆的物品中选择最大我w[i]的，然后分别将它试探性加到已分的两堆(a1,b1)中，若|a1+w[i]-b1|&gt;|a1-w[i]-b1|,泽加到b1中；否则加到a1中。已有神牛可以证明这样的最终结果与最优解的误差不超过16%。下面是格雷厄姆算法的实现。<br>代码2实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span>using namespace std;const int MAXN=20;int w[MAXN];int used[MAXN];int n,a,b;void Solve()&#123;	sort(w,w+n);<span class="comment">//排个序	a=0,b=0;	for(int i=n-1;i&gt;=0;i--)	&#123;		if(abs(a+w[i]-b)&lt;=abs(a-w[i]-b))		&#123;			a+=w[i];//放入a堆中			used[i]=true;		&#125;		else b+=w[i];//放入b堆中	&#125;&#125;int main()&#123;	cin&gt;&gt;n;	memset(used,0,sizeof(used));	for(int i=0;i&lt;n;i++)		cin&gt;&gt;w[i];	Solve();	printf(&quot;\n第一堆为:&quot;);	for(int i=0;i&lt;n;i++)		if(used[i])			printf(&quot;%d &quot;,w[i]); 	printf(&quot;\t合计 %d\n第二堆为:&quot;,a);	for(int i=0;i&lt;n;i++)		if(!used[i])			printf(&quot;%d &quot;,w[i]); 	printf(&quot;\t合计 %d\n&quot;,b);	system(&quot;pause&quot;);&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="部分算法代码链接"><a href="#部分算法代码链接" class="headerlink" title="部分算法代码链接"></a>部分算法代码链接</h2><p>线性表：<br><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/158.html">http://data.biancheng.net/view/158.html</a><br>    链栈：<br><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/171.html">http://data.biancheng.net/view/171.html</a><br>    链队：<br><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/174.html">http://data.biancheng.net/view/174.html</a><br>    堆：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/erwuhuoche/article/details/80368310">https://blog.csdn.net/erwuhuoche/article/details/80368310</a><br>    排序二叉树：<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/7106254596/">https://www.pianshen.com/article/7106254596/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40803710/article/details/80945367">https://blog.csdn.net/qq_40803710/article/details/80945367</a><br>6.哈希表<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sj-lv/p/3454777.html">https://www.cnblogs.com/sj-lv/p/3454777.html</a><br>    图的基本实现<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a45872055555/article/details/37668785">https://blog.csdn.net/a45872055555/article/details/37668785</a><br>    排序：（结合真题出现的快速排序来看）<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44487263/article/details/106585944">https://blog.csdn.net/qq_44487263/article/details/106585944</a><br>    枚举：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/LittleComputerRobot/article/details/75007681">https://blog.csdn.net/LittleComputerRobot/article/details/75007681</a><br>    贪心策略<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/mayifan_blog/article/details/85063336">https://blog.csdn.net/mayifan_blog/article/details/85063336</a><br>    分治策略比较经典的就是真题出现的汉诺塔和快速排序<br>    动态规划<br>最长公共子序列：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42034217/article/details/84720811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.chann">https://blog.csdn.net/weixin_42034217/article/details/84720811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.chann</a><br>最长回文子串：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ktigerhero3/article/details/49591233">https://blog.csdn.net/ktigerhero3/article/details/49591233</a><br>13广度优先搜索：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/breadth-first-search/">https://leetcode-cn.com/tag/breadth-first-search/</a><br>14深度优先搜索：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a396901990/article/details/45028741">https://blog.csdn.net/a396901990/article/details/45028741</a><br>15图论算法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiao_gis/article/details/84728194">https://blog.csdn.net/jiao_gis/article/details/84728194</a><br>16括号匹配算法<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cmusketeer/p/9890343.html">https://www.cnblogs.com/cmusketeer/p/9890343.html</a><br>17线段树<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AC-King/p/7789013.html">https://www.cnblogs.com/AC-King/p/7789013.html</a><br>18随机算法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lanchunhui/article/details/49123823">https://blog.csdn.net/lanchunhui/article/details/49123823</a><br>19近似算法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaofengcanyuexj/article/details/17527533?locationNum=4&fps=1">https://blog.csdn.net/xiaofengcanyuexj/article/details/17527533?locationNum=4&amp;fps=1</a></p>

    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Shi Defa
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://coderfishboy.github.io/2021/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记">https://coderfishboy.github.io/2021/03/28/数据结构与算法学习笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/28/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="C语言学习笔记">
      <i class="fa fa-chevron-left"></i> C语言学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/02/MySQL%E7%AC%94%E8%AE%B0/" rel="next" title="MySQL学习笔记">
      MySQL学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">1.线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84"><span class="nav-text">（1）数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%A0%88"><span class="nav-text">（2）栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%98%9F%E5%88%97"><span class="nav-text">（3）队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%93%BE%E8%A1%A8"><span class="nav-text">（4）链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%91"><span class="nav-text">2.树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A0%86"><span class="nav-text">（1）堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">（2）排序二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">3.哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-text">4.集合与映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9B%BE"><span class="nav-text">5.图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8E%92%E5%BA%8F"><span class="nav-text">6.排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">（1）冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9"><span class="nav-text">选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%BF%AB%E9%80%9F"><span class="nav-text">（3）快速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94"><span class="nav-text">希尔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%8F%92%E5%85%A5"><span class="nav-text">（5）插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E5%BD%92%E5%B9%B6"><span class="nav-text">（6）归并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%9F%A5%E6%89%BE"><span class="nav-text">7.查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">（1）折半查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%9E%9A%E4%B8%BE"><span class="nav-text">8.枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5"><span class="nav-text">9.贪心策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%92%B1%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="nav-text">（1）钱币找零问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98"><span class="nav-text">（2）活动选择问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">（3）背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-text">（4）多机调度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%B0%8F%E8%88%B9%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98"><span class="nav-text">（5）小船过河问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="nav-text">10.分治策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-text">11.递推与递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">12.动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%90%9C%E7%B4%A2"><span class="nav-text">13.搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">（1）广度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">（2）深度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95"><span class="nav-text">14.图论算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">1.Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%8D%E6%9D%82%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-text">2.复杂实现算法：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95"><span class="nav-text">15.字符串算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">（1）括号匹配算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">16.线段树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-text">17.随机算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="nav-text">18.近似算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E9%93%BE%E6%8E%A5"><span class="nav-text">部分算法代码链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shi Defa"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">Shi Defa</p>
  <div class="site-description" itemprop="description">来点小烧烤吗</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/coderfishboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;coderfishboy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/fabien00" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;fabien00" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shi Defa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">78k</span>
</div>





        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

